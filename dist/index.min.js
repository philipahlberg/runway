const MATCH_ALL="[^/]*",CATCH_ALL="([^/]+)",PARAMETER_PATTERN=/:([^\/]+)/,MATCH_TRAILING_SLASH="(?:[/]?(?=$))?",WILDCARD_PATTERN=/\*\*/g;class Path{constructor(t,e=!1){let s;t=t.replace(WILDCARD_PATTERN,MATCH_ALL);let n=[];for(;null!=(s=PARAMETER_PATTERN.exec(t));)t=t.replace(s[0],CATCH_ALL),n.push(s[1]);t.endsWith("/")||(t+=MATCH_TRAILING_SLASH),t=e?`^${t}$`:`^${t}`;const i=new RegExp(t,"i");this.pattern=i,this.keys=n}matches(t){return this.pattern.test(t)}matched(t){return this.pattern.exec(t)[0]}parse(t){return new ParsedExpression(t,this.pattern,this.keys)}transfer(t,e){const s=this.pattern.exec(t).slice(1);let n=e,i=s.length;for(;i--;)n=n.replace(":"+this.keys[i],s[i]);return n}}class ParsedExpression{constructor(t,e,s){this.values=e.exec(t).slice(1),this.url=t,this.keys=s,this.map=new Map}get(t){return this.values[this.keys.indexOf(t)]}set(t,e){return this.url.replace(this.get(t),e)}has(t){return void 0!==this.get(t)}all(){return this.keys.reduce((t,e,s)=>(t[e]=this.values[s],t),{})}entries(){return this.keys.map(t=>[t,this.get(t)])}*[Symbol.iterator](){const t=this.keys.length;for(let e=0;e<t;e++)yield[this.keys[e],this.values[e]]}}class Query extends Map{static from(t){return new Query(Object.entries(t))}static of(...t){return new Query(t)}static parse(t){t.startsWith("?")&&(t=t.substring(1));let e=[];return""!==t&&(e=t.split("&").map(t=>t.split("="))),new Query(e)}toString(){let t="";for(const[e,s]of this)t+=`&${e}=${s}`;return t.substring(1)}}function normalize(t){return("/"+t).replace(/[\/]+/g,"/")}function isFunction(t){if("function"!=typeof t)return!1;const e=t[Symbol.toStringTag];if("AsyncFunction"===e||"GeneratorFunction"===e)return!0;{const e=t.hasOwnProperty("arguments"),s=!t.hasOwnProperty("prototype");return e||s}}function isPromise(t){return"Promise"===t[Symbol.toStringTag]}const components=new WeakMap;function load(t,e){if("string"==typeof t)e(customelements.get(t));else if(components.has(t))e(components.get(t));else if(isFunction(t)){let s=t();isPromise(s)?s.then(s=>{components.set(t,s.default),e(s.default)}):(components.set(t,s),e(s))}else e(t)}class Route extends Path{constructor({path:t,exact:e,component:s,meta:n,children:i}){super(t,e),this.path=t,this.meta=n,this.component=s,this.children=i}async import(){return new Promise(t=>{load(this.component,e=>t(e))})}}class Routes{constructor(t){this.routes=t.map(t=>this.define(t))}define(t,e){return null!=e&&(t.path=normalize(e.path+"/"+t.path)),null!=t.children?t.children=t.children.map(e=>this.define(e,t)):t.exact=!0,new Route(t)}[Symbol.iterator](){return this.routes[Symbol.iterator]()}}class ActiveRoute{constructor(t,e){this.parameters=t.parse(e),this.matched=t.matched(e),this.query=Query.parse(e),this.hash=location.hash.substring(1)}}const RouterMixin=t=>(class extends t{constructor(){super(),this.router=window.Router}connectedCallback(){const t=this.getRootNode().host;t&&t.route&&(this.route=t.route),super.connectedCallback&&super.connectedCallback()}disconnectedCallback(){super.disconnectedCallback&&super.disconnectedCallback()}});class RouterLinkElement extends(RouterMixin(HTMLElement)){constructor(){super(),this.onClick=this.onClick.bind(this)}set to(t){this.setAttribute("to",t)}get to(){return this.getAttribute("to")}set exact(t){this.toggleAttribute("exact",t)}get exact(){return this.hasAttribute("exact")}set active(t){this.toggleAttribute("active",t)}get active(){return this.hasAttribute("active")}set disabled(t){this.toggleAttribute("disabled",t)}get disabled(){return this.hasAttribute("disabled")}connectedCallback(){super.connectedCallback(),this.addEventListener("click",this.onClick),addEventListener("location-change",this.onChange)}disconnectedCallback(){removeEventListener("location-change",this.onChange),super.disconnectedCallback()}onClick(){this.disabled||this.router.push(this.href)}onChange(t){const e=decodeURIComponent(location.pathname);this.href.startsWith("/")?this.active=this.exact?e===this.href:e.startsWith(this.href):this.active=e.endsWith(this.href)}}const EMPTY=Object.create(null);class Router{constructor(t,e){console.time("new Router"),this.views=[],this.routes=[],this.view=null,this.target=e,this.routes=new Routes(t),window.addEventListener("popstate",()=>{const t=decodeURIComponent(location.pathname),e=this.resolve(t);this.render(e,t)}),window.Router=this;const s=decodeURIComponent(location.pathname),n=this.resolve(s);console.timeEnd("new Router"),this.render(n,s)}push(t,{data:e,title:s}=EMPTY){history.pushState(e,s,t);const n=decodeURIComponent(location.pathname),i=this.resolve(n);this.render(i,n)}replace(t,{data:e,title:s}=EMPTY){history.replaceState(e,s,t);const n=decodeURIComponent(location.pathname),i=this.resolve(n);this.render(i,n)}resolve(t){let e=[];const s=n=>{let i=n.matches(t);if(i&&(e.push(n),null!=n.children))for(const t of n.children)s(t);return i};for(const t of this.routes)if(s(t))break;return e}async render(t,e){console.time("render"),console.time("import");const s=await Promise.all(t.map(t=>t.import()));let n;console.timeEnd("import");const i=t.length;for(let o=0;o<i;o++){const i=t[o],r=this.views[o],c=s[o],a=r instanceof c;let h;a?h=r:(h=new c,n&&r&&n.removeChild(r),this.views[o]=h);const l=new ActiveRoute(i,e);h.route=l;const u=l.parameters,d=c.properties;if(null!=d)for(const[t,e]of u)d.hasOwnProperty(t)&&(h[t]=e);a||null==n||(i.slot&&h.setAttribute("slot",i.slot),n.appendChild(h)),n=h}const o=this.views;for(let e=t.length;e<o.length;e++){const t=o[e];t.parentElement.removeChild(t)}null!=this.root&&this.root!==this.views[0]?this.target.replaceChild(this.views[0],this.root):this.target.appendChild(this.views[0]),this.root=this.views[0],console.timeEnd("render"),this.emit()}emit(){window.dispatchEvent(new Event("location-change"))}}export{Path,Query,Route,Routes,ActiveRoute,RouterLinkElement,RouterMixin,Router};
//# sourceMappingURL=index.min.js.map
