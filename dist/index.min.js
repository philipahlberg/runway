const MATCH_ALL="[^/]*",CATCH_ALL="([^/]+)",PARAMETER_PATTERN=/:([^\/]+)/,MATCH_TRAILING_SLASH="(?:[/]?(?=$))?",WILDCARD_PATTERN=/\*\*/g;class Path{constructor(t,e=!1){let s;t=t.replace(WILDCARD_PATTERN,MATCH_ALL);let i=[];for(;null!=(s=PARAMETER_PATTERN.exec(t));)t=t.replace(s[0],CATCH_ALL),i.push(s[1]);t.endsWith("/")||(t+=MATCH_TRAILING_SLASH),t=e?`^${t}$`:`^${t}`;const n=new RegExp(t,"i");this.pattern=n,this.keys=i}matches(t){return this.pattern.test(t)}matched(t){return this.pattern.exec(t)[0]}parse(t){return new ParsedExpression(t,this.pattern,this.keys)}transfer(t,e){const s=this.pattern.exec(t).slice(1);let i=e,n=s.length;for(;n--;)i=i.replace(":"+this.keys[n],s[n]);return i}}class ParsedExpression{constructor(t,e,s){this.values=e.exec(t).slice(1),this.url=t,this.keys=s,this.map=new Map}get(t){return this.values[this.keys.indexOf(t)]}set(t,e){return this.url.replace(this.get(t),e)}has(t){return void 0!==this.get(t)}all(){return this.keys.reduce((t,e,s)=>(t[e]=this.values[s],t),{})}entries(){return this.keys.map(t=>[t,this.get(t)])}*[Symbol.iterator](){const t=this.keys.length;for(let e=0;e<t;e++)yield[this.keys[e],this.values[e]]}}class Query extends Map{static from(t){return new Query(Object.entries(t))}static of(...t){return new Query(t)}static parse(t){t.startsWith("?")&&(t=t.substring(1));let e=[];return""!==t&&(e=t.split("&").map(t=>t.split("="))),new Query(e)}toString(){let t="";for(const[e,s]of this)t+=`&${e}=${s}`;return t.substring(1)}}function normalize(t){return("/"+t).replace(/[\/]+/g,"/")}function isFunction(t){if("function"!=typeof t)return!1;const e=t[Symbol.toStringTag];if("AsyncFunction"===e||"GeneratorFunction"===e)return!0;{const e=t.hasOwnProperty("arguments"),s=!t.hasOwnProperty("prototype");return e||s}}function isPromise(t){return"Promise"===t[Symbol.toStringTag]}const components=new WeakMap;function load(t,e){if("string"==typeof t)e(customelements.get(t));else if(components.has(t))e(components.get(t));else if(isFunction(t)){let s=t();isPromise(s)?s.then(s=>{components.set(t,s.default),e(s.default)}):(components.set(t,s),e(s))}else e(t)}class Route extends Path{constructor(t){super(t.path,t.exact),this.path=t.path,this.component=t.component,this.children=t.children||[],this.slot=t.slot,this.meta=Object.freeze(t.meta||{}),this.properties=Object.freeze(t.properties||{})}async import(){return new Promise(t=>{load(this.component,e=>t(e))})}}class Routes{constructor(t){this.routes=t.map(t=>this.define(t))}define(t,e){return null!=e&&(""===t.path?t.path=e.path:t.path=normalize(e.path+"/"+t.path)),null!=t.children?t.children=t.children.map(e=>this.define(e,t)):t.exact=!0,new Route(t)}[Symbol.iterator](){return this.routes[Symbol.iterator]()}}class ActiveRoute{constructor(t,e){this.parameters=t.parse(e),this.matched=t.matched(e),this.query=Query.parse(e),this.hash=location.hash.substring(1)}}const RouterMixin=t=>(class extends t{constructor(){super(),this.router=window.Router}connectedCallback(){const t=this.getRootNode().host;t&&t.route&&(this.route=t.route),super.connectedCallback&&super.connectedCallback()}disconnectedCallback(){super.disconnectedCallback&&super.disconnectedCallback()}});class RouterLinkElement extends(RouterMixin(HTMLElement)){constructor(){super(),this.onClick=this.onClick.bind(this)}set to(t){this.setAttribute("to",t)}get to(){return this.getAttribute("to")}set exact(t){this.toggleAttribute("exact",t)}get exact(){return this.hasAttribute("exact")}set active(t){this.toggleAttribute("active",t)}get active(){return this.hasAttribute("active")}set disabled(t){this.toggleAttribute("disabled",t)}get disabled(){return this.hasAttribute("disabled")}connectedCallback(){super.connectedCallback(),this.addEventListener("click",this.onClick),addEventListener("location-change",this.onChange)}disconnectedCallback(){removeEventListener("location-change",this.onChange),super.disconnectedCallback()}onClick(){this.disabled||this.router.push(this.href)}onChange(t){const e=decodeURIComponent(location.pathname);this.href.startsWith("/")?this.active=this.exact?e===this.href:e.startsWith(this.href):this.active=e.endsWith(this.href)}}const EMPTY=Object.create(null);class Router{constructor(t,e){this.views=[],this.routes=[],this.activeRoutes=[],this.target=e,this.routes=new Routes(t),window.addEventListener("popstate",()=>{const t=decodeURIComponent(location.pathname),e=this.resolve(t);this.render(e,t)}),window.Router=this;const s=decodeURIComponent(location.pathname),i=this.resolve(s);this.render(i,s)}push(t,{data:e,title:s}=EMPTY){history.pushState(e,s,t);const i=decodeURIComponent(location.pathname),n=this.resolve(i);this.render(n,i)}replace(t,{data:e,title:s}=EMPTY){history.replaceState(e,s,t);const i=decodeURIComponent(location.pathname),n=this.resolve(i);this.render(n,i)}resolve(t){let e=[];const s=i=>{let n=i.matches(t);if(n&&(e.push(i),null!=i.children))for(const t of i.children)s(t);return n};for(const t of this.routes)if(s(t))break;return e}async render(t,e){const s=Promise.all(t.map(t=>t.import()));let i;console.time("render");for(let e=0;e<t.length;e++){const s=t[e];if(this.activeRoutes.length<e+1){i=e;break}if(s!==this.activeRoutes[e]){i=e;break}}if(this.activeRoutes=t,i>0&&this.views.length>0){this.views[i].remove(),this.views=this.views.slice(0,i)}const n=await s,r=n.slice(i).map(t=>new t);for(let t=0;t<r.length-1;t++){const e=r[t],s=r[t+1];e.append(s)}this.views=this.views.concat(r);for(let s=0;s<this.views.length;s++){const i=this.views[s],r=t[s],o=n[s],a=new ActiveRoute(r,e),c=a.parameters,h=o.properties;if(null!=h){for(const[t,e]of c)h.hasOwnProperty(t)&&(i[t]=e);for(const t in r.properties)if(h.hasOwnProperty(t)){const e=r.properties[t];i[t]=e}}i.route=a,r.slot&&i.setAttribute("slot",r.slot)}if(i>0)this.views[i-1].append(r[0]);else{const t=this.target;for(;t.firstChild;)t.removeChild(t.firstChild);this.target.append(this.views[0])}console.timeEnd("render"),this.emit()}emit(){window.dispatchEvent(new Event("location-change"))}}export{Path,Query,Route,Routes,ActiveRoute,RouterLinkElement,RouterMixin,Router};
//# sourceMappingURL=index.min.js.map
