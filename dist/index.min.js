const MATCH_ALL="[^/]*",CATCH_ALL="([^/]+)",PARAMETER_PATTERN=/:([^\/]+)/,MATCH_TRAILING_SLASH="(?:[/]?(?=$))?",WILDCARD_PATTERN=/\*\*/g;class Path{constructor(t="",e=!1){let s;t=t.replace(WILDCARD_PATTERN,MATCH_ALL);let r=[];for(;null!=(s=PARAMETER_PATTERN.exec(t));)t=t.replace(s[0],CATCH_ALL),r.push(s[1]);t.endsWith("/")||(t+=MATCH_TRAILING_SLASH),t=e?`^${t}$`:`^${t}`;const n=new RegExp(t,"i");this.pattern=n,this.keys=r}matches(t){return this.pattern.test(t)}matched(t){let e=this.pattern.exec(t);return e&&e[0]||""}parse(t){return new ParsedExpression(t,this.pattern,this.keys)}transfer(t,e){const s=this.pattern.exec(t).slice(1);let r=e,n=s.length;for(;n--;)r=r.replace(":"+this.keys[n],s[n]);return r}}class ParsedExpression{constructor(t,e,s){this.url=t,this.keys=s,this.values=e.exec(t).slice(1)}get(t){return this.values[this.keys.indexOf(t)]}set(t,e){return this.url.replace(this.get(t),e)}has(t){return void 0!==this.get(t)}all(){return this.keys.reduce((t,e,s)=>(t[e]=this.values[s],t),{})}entries(){let t=[];for(let e=0;e<this.keys.length;e++)t.push([this.keys[e],this.values[e]]);return t}*[Symbol.iterator](){const t=this.keys.length;for(let e=0;e<t;e++)yield[this.keys[e],this.values[e]]}}class Query extends Map{static from(t){return new Query(Object.entries(t))}static of(...t){return new Query(t)}static parse(t){t.startsWith("?")&&(t=t.substring(1));let e=[];return""!==t&&(e=t.split("&").map(t=>t.split("="))),new Query(e)}toString(){let t="";for(const[e,s]of this)t+=`&${e}=${s}`;return t.substring(1)}}function normalize(t){return("/"+t).replace(/[\/]+/g,"/")}function isFunction(t){if("function"!=typeof t)return!1;const e=t[Symbol.toStringTag];if("AsyncFunction"===e||"GeneratorFunction"===e)return!0;{const e=t.hasOwnProperty("arguments"),s=!t.hasOwnProperty("prototype");return e||s}}function isPromise(t){return"Promise"===t[Symbol.toStringTag]}function clone(t){return Object.assign({},t)}function freeze(t){return Object.freeze(t)}function always(){return!0}const EMPTY=freeze(Object.create(null)),components=new WeakMap;function load(t,e){if("string"==typeof t)e(customelements.get(t));else if(components.has(t))e(components.get(t));else if(isFunction(t)){let s=t();isPromise(s)?s.then(s=>{let r=s.default||s;components.set(t,r),e(r)}):(components.set(t,s),e(s))}else e(t)}class Route extends Path{constructor(t){super(t.path,t.exact),this.path=t.path,this.exact=!0===t.exact,this.redirect=t.redirect,this.component=t.component,this.slot=t.slot,this.guard=t.guard||always,this.meta=freeze(t.meta||{}),this.properties=freeze(t.properties||{}),this.children=(t.children||[]).map(t=>createChildRoute(clone(t),this))}async import(){return new Promise(t=>{load(this.component,e=>t(e))})}}function createChildRoute(t,e){return""===t.path?t.path=e.path:t.path=normalize(e.path+"/"+t.path),null!=t.redirect&&(""===t.redirect?t.redirect=e.path:t.redirect=normalize(e.path+"/"+t.redirect)),null==t.children&&(t.exact=!0),new Route(t)}class ActivatedRoute{constructor(t,e){this.parameters=t.parse(e),this.matched=t.matched(e),this.query=Query.parse(e),this.hash=location.hash.substring(1)}}class Router{constructor(t,e){this.views=[],this.matched=[],this.routes=t.map(t=>new Route(t)),this.onPopstate=this.onPopstate.bind(this),window.Router=this,e&&this.connect(e)}connect(t){this.target=t,window.addEventListener("popstate",this.onPopstate);const e=decodeURIComponent(location.pathname),{matched:s,url:r}=this.match(e);return history.replaceState(null,null,r),this.render(s)}disconnect(){window.removeEventListener("popstate",this.onPopstate),this.teardown(),this.matched=[],this.target=null}onPopstate(){const t=decodeURIComponent(location.pathname),{matched:e}=this.match(t);this.render(e)}push(t,{data:e,title:s}=EMPTY){t=decodeURIComponent(t);const{matched:r,path:n}=this.match(t);return history.pushState(e,s,n),this.render(r)}replace(t,{data:e,title:s}=EMPTY){t=decodeURIComponent(t);const{matched:r,path:n}=this.match(t);return history.replaceState(e,s,n),this.render(r)}match(t){const e=(s,r)=>{const n=s.find(e=>e.matches(t)||e.guard());if(n){if(r.push(n),null!=n.redirect){const e=n.matched(t),s=n.transfer(e,n.redirect);return this.match(s)}return n.children?e(n.children,r):{matched:r,path:t}}return{matched:r,path:t}};return e(this.routes,[])}async render(t){const e=Promise.all(t.map(t=>t.import()));let s;for(let e=0;e<t.length;e++){const r=t[e];if(this.matched.length<e+1){s=e;break}if(r!==this.matched[e]){s=e;break}}null==s&&(s=t.length),this.matched=t;const r=this.views.slice(s);for(;r.length>0;){r.pop().remove()}this.views=this.views.slice(0,s);const n=await e,i=n.slice(s).map(t=>new t);for(let t=0;t<i.length-1;t++){const e=i[t],s=i[t+1];e.append(s)}this.views=this.views.concat(i);const o=decodeURIComponent(location.pathname);for(let e=0;e<this.views.length;e++){const s=this.views[e],r=t[e],i=n[e],a=new ActivatedRoute(r,o),h=a.parameters,c=i.properties;if(null!=c){for(const[t,e]of h)c.hasOwnProperty(t)&&(s[t]=e);for(const t in r.properties)if(c.hasOwnProperty(t)){const e=r.properties[t];s[t]=e}}s.route=a,r.slot&&s.setAttribute("slot",r.slot)}i.length>0&&(s>0?this.views[s-1].append(i[0]):this.target.append(this.views[0]))}teardown(){for(;this.views.length>0;){this.views.pop().remove()}}}export default Router;export{Path,Query,Route};
//# sourceMappingURL=index.min.js.map
