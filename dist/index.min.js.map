{"version":3,"file":"index.min.js","sources":["../src/EventEmitter.ts","../node_modules/@philipahlberg/query/dist/index.js","../node_modules/@philipahlberg/path/dist/index.js","../node_modules/@philipahlberg/scratchpad/dist/index.js","../src/utils.ts","../src/Route.ts","../src/History.ts","../src/Router.ts","../src/RouterLink.ts"],"sourcesContent":["import { EventEmitterListener } from './types';\r\n\r\nexport class EventEmitter {\r\n  map: Map<string, Set<EventEmitterListener>>;\r\n\r\n  constructor() {\r\n    this.map = new Map();\r\n  }\r\n\r\n  on(type: string, listener: EventEmitterListener) {\r\n    let listeners;\r\n    if (!this.map.has(type)) {\r\n      listeners = new Set();\r\n      this.map.set(type, listeners);\r\n    } else {\r\n      listeners = this.map.get(type);\r\n    }\r\n    listeners!.add(listener);\r\n  }\r\n\r\n  off(type: string, listener: EventEmitterListener) {\r\n    if (!this.map.has(type)) {\r\n      return;\r\n    }\r\n\r\n    const listeners = this.map.get(type);\r\n    listeners!.delete(listener);\r\n  }\r\n\r\n  emit(type: string, detail?: any) {\r\n    if (!this.map.has(type)) {\r\n      return;\r\n    }\r\n\r\n    const listeners = this.map.get(type);\r\n    for (const listener of listeners!) {\r\n      listener(detail);\r\n    }\r\n  }\r\n}","export class Query extends Map {\r\n    static from(object) {\r\n        return new Query(Object.entries(object));\r\n    }\r\n    static parse(string) {\r\n        if (/\\?/.test(string)) {\r\n            string = string.replace(/^.*\\?/, '');\r\n        }\r\n        if (/#/.test(string)) {\r\n            string = string.replace(/#.*$/, '');\r\n        }\r\n        let entries = [];\r\n        if (string !== '') {\r\n            entries = string.split('&')\r\n                .map((substring) => substring.split('='));\r\n        }\r\n        return new Query(entries);\r\n    }\r\n    toString() {\r\n        return Array.from(this.entries())\r\n            .map(entry => entry.join('='))\r\n            .join('&');\r\n    }\r\n}\r\nexport default Query;\r\n","/**\r\n * Matches anything until the next '/', '?' or '#'.\r\n * Replacement for wildcards in path declarations when building a RegExp.\r\n */\r\nconst MATCH_ALL = '[^/?#]*';\r\n/**\r\n * Captures anything until the next '/', '?' or '#'.\r\n * Replacement for parameters in path declarations when building a RegExp.\r\n */\r\nconst CATCH_ALL = '([^/?#]+)';\r\n/**\r\n * Matches an optional trailing '/', if it is not followed by anything.\r\n * Appended to the end of path declarations when building a RegExp.\r\n *\r\n * Notes:\r\n * - Does nothing on its own\r\n * - Does nothing without a trailing '$'\r\n *\r\n * @example\r\n * const pattern = new RegExp('^/abc' + MATCH_TRAILING_SLASH + '$');\r\n * pattern.test('/abc'); // => true\r\n * pattern.test('/abc/'); // => true\r\n * pattern.test('/abc/def'); // => false\r\n *\r\n */\r\nconst MATCH_TRAILING_SLASH = '(?:[/]?(?=$))?';\r\n/**\r\n * Matches an optional query string.\r\n */\r\nconst MATCH_TRAILING_QUERY = '(?:\\\\?.*)?';\r\n/**\r\n * Matches an optional hash string.\r\n */\r\nconst MATCH_TRAILING_HASH = '(?:#.*)?';\r\n/**\r\n * Matches '**'.\r\n *\r\n * Determines where to swap in a match-all pattern.\r\n */\r\nconst WILDCARD_PATTERN = /\\*\\*/g;\r\n/**\r\n * Matches ':param' and captures 'param'.\r\n *\r\n * Determines where to swap in a catch-all pattern, or\r\n * extracts parameter names from a path.\r\n */\r\nconst PARAMETER_PATTERN = /:([^\\/?#]+)/g;\n\n/**\r\n * Extract the keys in a path declaration.\r\n * @example\r\n * parse('/:a/:b/:c'); // => ['a', 'b', 'c']\r\n *\r\n * @param path A path declaration\r\n */\r\nconst parse = (path) => {\r\n    let keys = [];\r\n    let match;\r\n    while ((match = PARAMETER_PATTERN.exec(path)) != null) {\r\n        keys.push(match[1]);\r\n    }\r\n    return keys;\r\n};\n\n/**\r\n * Create a regular expression from a path with (optional) encoded parameters in it.\r\n * `exact` determines if the resulting expression should match\r\n * any superset of the given path or only match equal segment-length paths.\r\n *\r\n * @example\r\n * // not exact\r\n * compile('/:a').test('/b'); // => true\r\n * compile('/:a').test('/a/b'); // => true\r\n * // exact\r\n * compile('/:a', true).test('/a'); // => true\r\n * compile('/:a', true).test('/a/b'); // => false\r\n *\r\n * @param path A path declaration\r\n * @param exact If `true`, the resulting expression will only match\r\n * 1:1 (instead of matching any superset of the given path).\r\n */\r\nconst compile = (path, exact = false) => (new RegExp('^' +\r\n    path\r\n        // Replace '**' with a matching group\r\n        .replace(WILDCARD_PATTERN, MATCH_ALL)\r\n        // Replace ':key' with a catching group\r\n        .replace(PARAMETER_PATTERN, CATCH_ALL)\r\n    // Match an optional trailing slash\r\n    + MATCH_TRAILING_SLASH\r\n    // If exact, only match completely\r\n    + (exact\r\n        ? MATCH_TRAILING_QUERY + MATCH_TRAILING_HASH + '$'\r\n        : ''), 'i'));\n\n/**\r\n * Retrieve the values embedded in a string using a\r\n * regular expression obtained from `compile`.\r\n *\r\n * @example\r\n * const pattern = compile('/:a');\r\n * execute(pattern, '/value'); // => ['value']\r\n *\r\n * @param pattern The pattern returned from `compile`\r\n * @param path The live path\r\n */\r\nconst execute = (pattern, path) => ((pattern.exec(path) || []).slice(1));\n\nconst zip = (a, b) => (a.map((v, i) => [v, b[i]]));\r\n/**\r\n * Convert an array of keys and an array of values into a Map.\r\n *\r\n * @example\r\n * const keys = parse('/:a/:b');\r\n * const pattern = compile('/:a/:b');\r\n * const values = execute(pattern, '/some/path');\r\n * map(keys, values); // => Map {'a' => 'some', 'b' => 'path'}\r\n *\r\n * @param keys The keys returned from `parse`\r\n * @param values The values returned from `execute`\r\n */\r\nconst map = (keys, values) => (new Map(zip(keys, values)));\n\n/**\r\n * Convert an array of keys and an array of values into a plain object.\r\n * @example\r\n * const keys = parse('/:a/:b');\r\n * const pattern = compile('/:a/:b');\r\n * const values = execute(pattern, '/some/path');\r\n * object(keys, values); // => { a: 'some', b: 'path' }\r\n *\r\n * @param keys The keys returned from `parse`\r\n * @param values The values returned from `execute`\r\n */\r\nconst object = (keys, values) => (keys.reduce((acc, key, i) => {\r\n    acc[key] = values[i];\r\n    return acc;\r\n}, {}));\n\nclass Path {\r\n    constructor(path, exact = false) {\r\n        this.keys = parse(path);\r\n        this.pattern = compile(path, exact);\r\n    }\r\n    /**\r\n     * Test if the Path matches the given string.\r\n     *\r\n     * @example\r\n     * const path = new Path('/:a/:b/:c');\r\n     * path.matches('/1/2/3'); // => true\r\n     * path.matches('/1/2'); // => false\r\n     * path.matches('/1/2/3/4'); // => true\r\n     *\r\n     * @param string The string to test against\r\n     */\r\n    matches(string) {\r\n        return this.pattern.test(string);\r\n    }\r\n    /**\r\n     * Extract the matched part of the given string according to this Path.\r\n     *\r\n     * @example\r\n     * const path = new Path('/:a/:b/:c');\r\n     * path.matched('/1/2/3'); // => '/1/2/3'\r\n     * path.matched('/1/2/3/4'); // => '1/2/3'\r\n     *\r\n     * @param string The string to match against\r\n     */\r\n    matched(string) {\r\n        const matched = this.pattern.exec(string);\r\n        return matched && matched[0] || '';\r\n    }\r\n    /**\r\n     * Extract the values in the given string according to this Path's\r\n     * initial declaration.\r\n     *\r\n     * @example\r\n     * const path = new Path('/:a/:b/:c');\r\n     * path.values('/1/2/3'); // => ['1', '2', '3']\r\n     *\r\n     * @param string The string to extract values from\r\n     */\r\n    values(string) {\r\n        return execute(this.pattern, string);\r\n    }\r\n    /**\r\n     * Extract the values in the given string, and combine them\r\n     * with the keys for this Path to create a Map instance.\r\n     *\r\n     * @example\r\n     * const path = new Path('/:a/:b/:c');\r\n     * path.toMap('/1/2/3'); // => Map { 'a' => '1', 'b' => '2', 'c' => '3' }\r\n     *\r\n     * @param string The string to extract values from\r\n     */\r\n    toMap(string) {\r\n        const values = this.values(string);\r\n        return map(this.keys, values);\r\n    }\r\n    /**\r\n     * Extract the values in the given string, and combine them\r\n     * with the keys for this Path to create a simple object.\r\n     *\r\n     * @example\r\n     * const path = new Path('/:a/:b/:c');\r\n     * path.toMap('/1/2/3'); // => { a: '1', b: '2', c: '3' }\r\n     *\r\n     * @param string The string to extract values from\r\n     */\r\n    toObject(string) {\r\n        const values = this.values(string);\r\n        return object(this.keys, values);\r\n    }\r\n    /**\r\n     * Transfer parameters in a string (`source`) according to the\r\n     * Path declaration to construct another path (`target`).\r\n     * @example\r\n     * const path = new Path('/:a/:b/:c');\r\n     * path.transfer('/1/2/3', '/:a'); // => '/1'\r\n     * path.transfer('/1/2/3', '/:b'); // => '/2'\r\n     * path.transfer('/1/2/3', '/:c/:b/:a/abc'); // => '/3/2/1/abc'\r\n     *\r\n     * @param source The string that contains values\r\n     * @param target The path that will receive values\r\n     */\r\n    transfer(source, target) {\r\n        const values = this.values(source);\r\n        let i = values.length;\r\n        while (i--) {\r\n            target = target\r\n                .replace(':' + this.keys[i], values[i]);\r\n        }\r\n        return target;\r\n    }\r\n}\n\nexport default Path;\nexport { Path };\n","/**\r\n * Convert 'PascalCase' or 'camelCase' to 'dash-case'.\r\n * @param str A PascalCase og camelCase string\r\n */\r\nfunction toDashCase(str) {\r\n    return str.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase();\r\n}\r\n/**\r\n * Convert 'dash-case' to 'camelCase'.\r\n * @param str A camelCase string\r\n */\r\nfunction toCamelCase(str) {\r\n    return str.replace(/-([a-z])/ig, (m) => m[1].toUpperCase());\r\n}\r\n/**\r\n * Determine if a given value can be interpreted as a boolean.\r\n * @example\r\n * isBoolean(true); // => true\r\n * isBoolean(false); // => true\r\n * isBoolean('false'); // => true\r\n * isBoolean('true'); // => true\r\n *\r\n * @param value The value to inspect\r\n */\r\nfunction isBoolean(value) {\r\n    return value != null && (value === 'false' || value === 'true' || typeof value === 'boolean');\r\n}\r\n/**\r\n * Coerce a value to a boolean, with special edge-case handling not present\r\n * in `Boolean`.\r\n * @example\r\n * Boolean('false'); // => true\r\n * toBoolean('false'); // => false\r\n *\r\n * @param value\r\n */\r\nfunction toBoolean(value) {\r\n    return value !== 'false' && Boolean(value);\r\n}\r\n/**\r\n *\r\n * @param value\r\n */\r\nfunction isPrimitive(value) {\r\n    const type = typeof value;\r\n    return type === 'number' ||\r\n        type === 'string' ||\r\n        type === 'boolean' ||\r\n        type === 'symbol';\r\n}\r\n/**\r\n * Determines if the given object is a callable function.\r\n * An ES2015 class will return false, while ordinary functions,\r\n * arrow functions, generator functions and async functions return true.\r\n */\r\nfunction isCallable(object) {\r\n    if (!(typeof object === 'function')) {\r\n        return false;\r\n    }\r\n    /**\r\n     * Values for `hasOwnProperty` on functions:\r\n     *\r\n     *           | Class | Ordinary | Arrow | Async | Generator |\r\n     * ---------------------------------------------------------|\r\n     * arguments | false |   true   | false | false |   false   |\r\n     * prototype | true  |   true   | false | false |   true    |\r\n     *\r\n     */\r\n    const tag = object[Symbol.toStringTag];\r\n    if (tag === 'AsyncFunction' || tag === 'GeneratorFunction') {\r\n        return true;\r\n    }\r\n    else if (!object.hasOwnProperty('prototype')) {\r\n        // Arrow functions do not have a `prototype` property, which classes do.\r\n        return true;\r\n    }\r\n    else {\r\n        // // Ordinary functions have an `arguments` property, which classes do not.\r\n        // Note: Does not work in certain environments.\r\n        // RegExp method is more reliable.\r\n        // const isNormalFunction = object.hasOwnProperty('arguments');\r\n        return !/class/.test(object.toString());\r\n    }\r\n}\r\n/**\r\n * Determine if the given object is a promise.\r\n * @param object The object to inspect\r\n */\r\nfunction isPromise(object) {\r\n    return object[Symbol.toStringTag] === 'Promise';\r\n}\r\n/**\r\n * Determine if the given object is an ES module (the return value of `import()`)\r\n * or a shim (like `require()`)\r\n * @example\r\n * isModule(import('./module.js')); // => true\r\n * // Does not work with `await`:\r\n * isModule(await import('./module.js')); // => false\r\n *\r\n * @param object The object to inspect\r\n */\r\nfunction isModule(object) {\r\n    return object[Symbol.toStringTag] === 'Module' || object.__esModule === true;\r\n}\r\nfunction has(target, prop) {\r\n    return target.hasOwnProperty(prop);\r\n}\r\nfunction empty() {\r\n    return Object.create(null);\r\n}\r\n/**\r\n * Shorthand for `Object.assign`.\r\n */\r\nfunction clone(object) {\r\n    return Object.assign(empty(), object);\r\n}\r\n/**\r\n * Shorthand for `Object.freeze`.\r\n * @param object\r\n */\r\nfunction freeze(object) {\r\n    return Object.freeze(object);\r\n}\r\n/**\r\n * Always returns `true`.\r\n */\r\nfunction always() {\r\n    return true;\r\n}\r\n/**\r\n * Always returns `false`.\r\n */\r\nfunction never() {\r\n    return false;\r\n}\r\n/**\r\n * Shorthand for `decodeURIComponent`.\r\n */\r\nfunction decode(str) {\r\n    return decodeURIComponent(str);\r\n}\r\n/**\r\n * Combine two arrays to an array of tuples.\r\n */\r\nfunction zip(a, b) {\r\n    return a.map((v, i) => [v, b[i]]);\r\n}\r\n/**\r\n * Separate an array of tuples into two arrays.\r\n */\r\nfunction unzip(array) {\r\n    return [\r\n        array.map(v => v[0]),\r\n        array.map(v => v[1])\r\n    ];\r\n}\r\n/**\r\n * Convert an array of tuples to an object in which each key\r\n * is the first element of the tuple and the value is the\r\n * second element of the tuple.\r\n */\r\nfunction dictionary(pairs) {\r\n    let index = -1;\r\n    const length = pairs.length;\r\n    const result = {};\r\n    while (++index < length) {\r\n        const pair = pairs[index];\r\n        result[pair[0]] = pair[1];\r\n    }\r\n    return result;\r\n}\r\nconst EMPTY = freeze(empty());\r\nconst timeouts = new WeakMap();\r\nfunction debounce(fn) {\r\n    const wrapper = () => {\r\n        fn();\r\n        timeouts.delete(fn);\r\n    };\r\n    return () => {\r\n        clearTimeout(timeouts.get(fn));\r\n        timeouts.set(fn, setTimeout(wrapper, 1));\r\n    };\r\n}\r\nconst called = new WeakSet();\r\nfunction once(fn) {\r\n    return () => {\r\n        if (!called.has(fn)) {\r\n            fn();\r\n            called.add(fn);\r\n        }\r\n    };\r\n}\r\nconst input = new WeakMap();\r\nconst output = new WeakMap();\r\nfunction cache(fn) {\r\n    return (...args) => {\r\n        const previous = input.get(fn);\r\n        const equal = previous && args.every((item, i) => item === previous[i]);\r\n        if (equal) {\r\n            return output.get(fn);\r\n        }\r\n        else {\r\n            const result = fn(...args);\r\n            input.set(fn, args);\r\n            output.set(fn, result);\r\n            return result;\r\n        }\r\n    };\r\n}\r\n/**\r\n * `requestIdleCallback` as a Promise.\r\n */\r\nfunction idle() {\r\n    return new Promise(resolve => {\r\n        requestIdleCallback(() => {\r\n            resolve();\r\n        });\r\n    });\r\n}\r\n/**\r\n * `setTimeout` as a Promise.\r\n * @param ms The minimum number of milliseconds that should elapse\r\n * before the function is called.\r\n */\r\nfunction timeout(ms = 0) {\r\n    return new Promise(resolve => {\r\n        setTimeout(() => {\r\n            resolve();\r\n        }, ms);\r\n    });\r\n}\r\n/**\r\n * `requestAnimationFrame` as a Promise.\r\n */\r\nfunction frame() {\r\n    return new Promise(resolve => {\r\n        requestAnimationFrame(() => {\r\n            resolve();\r\n        });\r\n    });\r\n}\r\nfunction createElement(tag, options = EMPTY, children = []) {\r\n    const attributes = options.attributes || {};\r\n    const properties = options.properties || {};\r\n    const namespace = options.namespace;\r\n    const ns = namespace && namespace.toLowerCase() === 'svg'\r\n        ? 'http://www.w3.org/2000/svg'\r\n        : 'http://www.w3.org/1999/xhtml';\r\n    const element = document.createElementNS(ns, tag);\r\n    Object.assign(element, properties);\r\n    for (const key in attributes) {\r\n        element.setAttribute(key, attributes[key]);\r\n    }\r\n    for (const node of children) {\r\n        element.appendChild(node);\r\n    }\r\n    return element;\r\n}\n\nexport { toDashCase, toCamelCase, isBoolean, toBoolean, isPrimitive, isCallable, isPromise, isModule, has, empty, clone, freeze, always, never, decode, zip, unzip, dictionary, EMPTY, debounce, once, cache, idle, timeout, frame, createElement };\n","/**\r\n * Append a leading slash, and remove all excess slashes.\r\n */\r\nexport function normalize(path: string): string {\r\n  return ('/' + path).replace(/[\\/]+/g, '/');\r\n}\r\n\r\n/**\r\n * Shorthand for `decodeURIComponent`\r\n */\r\nexport function decode(str: string): string {\r\n  return decodeURIComponent(str);\r\n}\r\n","import Query from '@philipahlberg/query';\r\nimport Path from '@philipahlberg/path';\r\nimport { empty, always } from '@philipahlberg/scratchpad';\r\nimport { normalize, decode } from './utils';\r\nimport {\r\n  Component,\r\n  GuardFn,\r\n  PropertiesFn,\r\n  Record,\r\n  Snapshot,\r\n  Module,\r\n  CustomElement\r\n} from './types';\r\n\r\nexport class Route extends Path {\r\n  private static cache = new WeakMap<any, CustomElement>();\r\n  path: string;\r\n  exact: boolean;\r\n  component: Component;\r\n  redirect?: string;\r\n  slot?: string;\r\n  guard: GuardFn;\r\n  properties: PropertiesFn;\r\n  children: Route[];\r\n\r\n  constructor(record: Record) {\r\n    let { path, component, exact,\r\n      redirect, slot, guard,\r\n      properties, children } = record;\r\n\r\n    // Path should be exact if the route\r\n    // does not have any children,\r\n    // but only if the record does not\r\n    // specify anything\r\n    if (exact == null) {\r\n      exact = (\r\n        children == null ||\r\n        children.length === 0\r\n      );\r\n    }\r\n\r\n    super(path, exact);\r\n    this.path = path;\r\n    this.exact = exact;\r\n    this.redirect = redirect;\r\n    this.component = typeof component === 'string'\r\n      ? customElements.get(component)\r\n      : component;\r\n    this.slot = slot;\r\n    this.guard = guard || always;\r\n    this.properties = properties || empty;\r\n    this.children = (children || []).map(child =>\r\n      createChildRoute(child, this)\r\n    );\r\n  }\r\n\r\n  async import(): Promise<CustomElement> {\r\n    const cache = Route.cache;\r\n    const component = this.component;\r\n\r\n    if (isHTMLElement(component)) {\r\n      return component;\r\n    } else if (cache.has(component)) {\r\n      return cache.get(component)!;\r\n    } else {\r\n      const res = await (this.component as () => Module)();\r\n      const ctor = res.default as CustomElement;\r\n      cache.set(component, ctor);\r\n      return ctor;\r\n    }\r\n  }\r\n\r\n  snapshot(source: Location | URL): Snapshot {\r\n    const { pathname, search, hash } = source;\r\n    return {\r\n      parameters: this.toMap(decode(pathname)),\r\n      query: Query.parse(decode(search)),\r\n      matched: this.matched(decode(pathname)),\r\n      hash: hash.substring(1)\r\n    };\r\n  }\r\n}\r\n\r\nfunction createChildRoute(record: Record, parent: Route): Route {\r\n  if (record.path === '') {\r\n    record.path = parent.path;\r\n  } else {\r\n    record.path = normalize(parent.path + '/' + record.path);\r\n  }\r\n  if (record.redirect != null) {\r\n    record.redirect = normalize(parent.path + '/' + record.redirect);\r\n  }\r\n  return new Route(record);\r\n}\r\n\r\nfunction isHTMLElement(o: any): o is CustomElement {\r\n  return HTMLElement.isPrototypeOf(o);\r\n}","import { EventEmitter } from './EventEmitter';\r\nimport { NavigationOptions } from './types';\r\nimport { decode } from './utils';\r\n\r\nconst h = history;\r\n\r\nexport class History extends EventEmitter {\r\n  constructor() {\r\n    super();\r\n    this.onPopstate = this.onPopstate.bind(this);\r\n  }\r\n\r\n  connect() {\r\n    window.addEventListener('popstate', this.onPopstate);\r\n  }\r\n\r\n  disconnect() {\r\n    window.removeEventListener('popstate', this.onPopstate);\r\n  }\r\n\r\n  onPopstate() {\r\n    const path = decode(location.pathname);\r\n    this.emit('pop', { path });\r\n  }\r\n\r\n  push(path: string, options: NavigationOptions = {}) {\r\n    const { data, title } = options;\r\n    h.pushState(data, title || document.title, path);\r\n    this.emit('push', { path });\r\n  }\r\n\r\n  replace(path: string, options: NavigationOptions = {}) {\r\n    const { data, title } = options;\r\n    h.replaceState(data, title || document.title, path);\r\n    this.emit('replace', { path });\r\n  }\r\n\r\n  pop(n: number = 1) {\r\n    h.go(-n);\r\n  }\r\n}","import { EventEmitter } from './EventEmitter';\r\nimport { Route } from './Route';\r\nimport { History } from './History';\r\nimport { decode } from './utils';\r\nimport { Record, CustomElement, NavigationOptions } from './types';\r\n\r\nexport interface SearchResult {\r\n  matched: Route[];\r\n  path: string;\r\n}\r\n\r\nexport class Router extends EventEmitter {\r\n  isConnected: boolean;\r\n  history: History;\r\n  routes: Route[];\r\n  elements: HTMLElement[];\r\n  activeRoutes: Route[];\r\n  root?: HTMLElement;\r\n\r\n  constructor(records: Record[]) {\r\n    super();\r\n    this.isConnected = false;\r\n    this.elements = [];\r\n    this.activeRoutes = [];\r\n    this.routes = records.map(record => new Route(record));\r\n    this.onPopstate = this.onPopstate.bind(this);\r\n    this.history = new History();\r\n    this.history.on('pop', this.onPopstate);\r\n  }\r\n\r\n  /**\r\n   * Connect the router to an element.\r\n   * This checks the current location for matching,\r\n   * and renders those matched elements.\r\n   */\r\n  async connect(root: HTMLElement): Promise<void> {\r\n    this.isConnected = true;\r\n    this.root = root;\r\n    const to = decode(location.pathname);\r\n    const { matched, path } = this.match(to);\r\n    this.history.connect();\r\n    this.history.replace(path);\r\n    await this.render(matched);\r\n    this.emit('connect');\r\n  }\r\n\r\n  /**\r\n   * Disconnect the router from it's current root element.\r\n   * This removes all the elements currently rendered, and\r\n   * removes all listeners, effectively leaving the router inactive.\r\n   */\r\n  disconnect(): void {\r\n    this.isConnected = false;\r\n    this.activeRoutes = [];\r\n    this.root = undefined;\r\n    this.teardown();\r\n    this.history.disconnect();\r\n    this.emit('disconnect');\r\n  }\r\n\r\n  private onPopstate(to: string): void {\r\n    const { matched, path } = this.match(to);\r\n    if (to !== path) {\r\n      this.history.replace(path);\r\n    }\r\n    this.emit('pop');\r\n    this.render(matched);\r\n  }\r\n\r\n  /**\r\n   * Push a history entry onto the stack.\r\n   */\r\n  async push(to: string, options?: NavigationOptions): Promise<void> {\r\n    to = decode(to);\r\n    const { matched, path } = this.match(to);\r\n    this.history.push(path, options);\r\n    this.emit('push');\r\n    await this.render(matched);\r\n  }\r\n\r\n  /**\r\n   * Replace the topmost entry in the history stack.\r\n   */\r\n  async replace(to: string, options?: NavigationOptions): Promise<void> {\r\n    to = decode(to);\r\n    const { matched, path } = this.match(to);\r\n    this.history.replace(path, options);\r\n    this.emit('replace');\r\n    await this.render(matched);\r\n  }\r\n\r\n  /**\r\n   * Pop the top `n` entries off of history stack.\r\n   */\r\n  pop(n: number = 1) {\r\n    // triggers onpop(), so no need to render here\r\n    this.history.pop(n);\r\n  }\r\n\r\n  private search(path: string, routes: Route[], matched: Route[]): SearchResult {\r\n    const route = routes.find(r => r.matches(path) && r.guard());\r\n\r\n    if (route) {\r\n      matched.push(route);\r\n      if (route.redirect) {\r\n        // transfer any matched parameters\r\n        const from = route.matched(path);\r\n        const to = route.redirect;\r\n        const redirected = route.transfer(from, to);\r\n        // and start over\r\n        return this.search(redirected, this.routes, []);\r\n      } else if (route.children) {\r\n        // Search through the children\r\n        return this.search(path, route.children, matched);\r\n      } else {\r\n        return { matched, path };\r\n      }\r\n    } else {\r\n      // End the search here\r\n      return { matched, path };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Search for the elements that would match the given path.\r\n   * If a redirect is encountered, it will be followed.\r\n   * The resulting path and the matched elements are returned.\r\n   */\r\n  private match(path: string): SearchResult {\r\n    return this.search(path, this.routes, []);\r\n  }\r\n\r\n  /**\r\n   * Render the given routes.\r\n   * The routes are assumed to be nested.\r\n   */\r\n  private async render(matchedRoutes: Route[]) {\r\n    if (this.root == undefined) {\r\n      return;\r\n    }\r\n\r\n    // Importing early, but deliberately not awaiting\r\n    const load = Promise.all(matchedRoutes.map(route => route.import()));\r\n\r\n    // Find the index at which the matched routes\r\n    // differ from the active routes.\r\n    let startIndex;\r\n    const activeRoutes = this.activeRoutes;\r\n    const length = Math.min(matchedRoutes.length, activeRoutes.length);\r\n    for (startIndex = 0; startIndex < length; startIndex++) {\r\n      if (matchedRoutes[startIndex] !== activeRoutes[startIndex]) break;\r\n    }\r\n\r\n    this.activeRoutes = matchedRoutes;\r\n\r\n    // Remove the obsolete elements from the DOM\r\n    const removals = this.elements.slice(startIndex);\r\n    while (removals.length > 0) {\r\n      const element = removals.pop();\r\n      if (element && element.parentElement) {\r\n        element.parentElement.removeChild(element!);\r\n      }\r\n    }\r\n\r\n    // Discard references to the removed elements\r\n    this.elements = this.elements.slice(0, startIndex);\r\n\r\n    // Wait for any asynchronous components to load\r\n    const components = await load;\r\n    // Create the new elements\r\n    const additions = components\r\n      .slice(startIndex)\r\n      .map((Component: CustomElement) => new Component());\r\n\r\n    this.elements = this.elements.concat(additions);\r\n\r\n    // Add slot attributes if needed\r\n    for (let i = startIndex; i < this.elements.length; i++) {\r\n      const element = this.elements[i];\r\n      const route = this.activeRoutes[i];\r\n      if (route.slot) {\r\n        element.setAttribute('slot', route.slot);\r\n      }\r\n    }\r\n\r\n    // Combine the newly created elements in order\r\n    // Note: they are not connected to the DOM here\r\n    for (let i = 0; i < additions.length - 1; i++) {\r\n      const parent = additions[i];\r\n      const child = additions[i + 1];\r\n      parent.appendChild(child);\r\n    }\r\n\r\n    // Resolve any new properties\r\n    this.updateProperties();\r\n\r\n    // If there are any additions, they need to be rendered\r\n    if (additions.length > 0) {\r\n      if (startIndex > 0) {\r\n        // Some reuse\r\n        // Connect the new elements to the deepest reused element,\r\n        // implicitly rendering them\r\n        this.elements[startIndex - 1].appendChild(additions[0]);\r\n      } else {\r\n        // No reuse\r\n        this.root.appendChild(this.elements[0]);\r\n      }\r\n    }\r\n\r\n    this.emit('render');\r\n  }\r\n\r\n  /**\r\n   * Update all `:param` bindings and `properties` functions in the tree.\r\n   */\r\n  private updateProperties() {\r\n    for (let i = 0; i < this.elements.length; i++) {\r\n      const element = this.elements[i];\r\n      const definition = customElements.get(\r\n        element.tagName.toLowerCase()\r\n      );\r\n      const options = definition.properties;\r\n      const route = this.activeRoutes[i];\r\n\r\n      if (options != undefined) {\r\n        const snapshot = route.snapshot(window.location);\r\n        const parameters = snapshot.parameters;\r\n        // Resolve parameters from path\r\n        for (const [key, value] of parameters) {\r\n          if (options.hasOwnProperty(key)) {\r\n            element[key] = value;\r\n          }\r\n        }\r\n\r\n        // Resolve additional properties from route\r\n        const properties = route.properties(snapshot);\r\n        const keys = Object.keys(properties);\r\n        for (const key of keys) {\r\n          if (options.hasOwnProperty(key)) {\r\n            element[key] = properties[key];\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove all currently active elements.\r\n   */\r\n  private teardown() {\r\n    while (this.elements.length > 0) {\r\n      const element = this.elements.pop();\r\n      // need to use parentElement.removeChild()\r\n      // (as opposed to element.remove())\r\n      // to avoid bug in Edge\r\n      if (element && element.parentElement) {\r\n        element.parentElement.removeChild(element!);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default Router;\r\n","import { Router } from './Router';\r\nimport { decode } from './utils';\r\nimport { RouterLinkOptions } from './types';\r\n\r\nexport class RouterLink extends HTMLElement {\r\n  static observedAttributes = ['disabled', 'to'];\r\n  static tagName = 'router-link';\r\n  private static router: Router;\r\n\r\n  static define(tagName = 'router-link', options: RouterLinkOptions) {\r\n    this.tagName = tagName;\r\n    this.router = options.router;\r\n    customElements.define(tagName, this);\r\n  }\r\n\r\n  constructor() {\r\n    super();\r\n    this.onClick = this.onClick.bind(this);\r\n    this.onChange = this.onChange.bind(this);\r\n  }\r\n\r\n  set to(v: string) {\r\n    this.setAttribute('to', v);\r\n  }\r\n\r\n  get to() {\r\n    return this.getAttribute('to') as string;\r\n  }\r\n\r\n  set exact(v: boolean) {\r\n    this.toggleAttribute('exact', v);\r\n    this.active = this.test(decode(location.pathname));\r\n  }\r\n\r\n  get exact(): boolean {\r\n    return this.hasAttribute('exact');\r\n  }\r\n\r\n  set active(v: boolean) {\r\n    this.toggleAttribute('active', v);\r\n  }\r\n\r\n  get active(): boolean {\r\n    return this.hasAttribute('active');\r\n  }\r\n\r\n  set disabled(v: boolean) {\r\n    this.toggleAttribute('disabled', v);\r\n  }\r\n\r\n  get disabled(): boolean {\r\n    return this.hasAttribute('disabled');\r\n  }\r\n\r\n  get router(): Router {\r\n    return RouterLink.router;\r\n  }\r\n\r\n  attributeChangedCallback(attr: string, oldValue: string, newValue: string) {\r\n    if (oldValue === newValue) {\r\n      return;\r\n    }\r\n\r\n    if (attr === 'disabled') {\r\n      const hasValue = newValue != null;\r\n      if (hasValue) {\r\n        this.active = false;\r\n        this.router.off('render', this.onChange);\r\n      } else {\r\n        this.router.on('render', this.onChange);\r\n        this.onChange();\r\n      }\r\n    } else if (attr === 'to') {\r\n      const a = this.querySelector('a');\r\n      if (a) {\r\n        a.href = newValue;\r\n      }\r\n      this.active = this.test(decode(location.pathname));\r\n    }\r\n  }\r\n\r\n  connectedCallback() {\r\n    const a = this.querySelector('a');\r\n    if (a) {\r\n      if (!this.to) {\r\n        this.to = decode(a.pathname);\r\n      } else {\r\n        a.href = this.to;\r\n      }\r\n    }\r\n    this.addEventListener('click', this.onClick);\r\n    this.router.on('render', this.onChange);\r\n    this.onChange();\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    this.removeEventListener('click', this.onClick);\r\n    this.router.off('render', this.onChange);\r\n  }\r\n\r\n  toggleAttribute(name: string, predicate: boolean) {\r\n    if (predicate != null) {\r\n      if (predicate) {\r\n        this.setAttribute(name, '');\r\n      } else {\r\n        this.removeAttribute(name);\r\n      }\r\n    } else {\r\n      this.toggleAttribute(name, !this.hasAttribute(name));\r\n    }\r\n  }\r\n\r\n  test(path: string): boolean {\r\n    const to = this.to;\r\n    if (to.startsWith('/')) {\r\n      return this.exact\r\n        ? path === to\r\n        : path.startsWith(to);\r\n    } else {\r\n      return path.endsWith(to);\r\n    }\r\n  }\r\n\r\n  onClick(event: MouseEvent) {\r\n    if (\r\n      // Ignore clicks with modifiers\r\n      event.metaKey ||\r\n      event.altKey ||\r\n      event.ctrlKey ||\r\n      event.shiftKey ||\r\n      // Ignore prevented clicks\r\n      event.defaultPrevented ||\r\n      // Ignore right mouse button clicks\r\n      (event.button !== undefined &&\r\n      event.button !== 0)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    event.preventDefault();\r\n    if (this.disabled || !this.to) {\r\n      return;\r\n    } else {\r\n      this.router.push(this.to);\r\n    }\r\n  }\r\n\r\n  onChange() {\r\n    this.active = this.test(decode(location.pathname));\r\n  }\r\n}\r\n\r\nexport default RouterLink;\r\n"],"names":["[object Object]","this","map","Map","type","listener","listeners","has","get","Set","set","add","delete","detail","Query","object","Object","entries","string","test","replace","split","substring","Array","from","entry","join","WILDCARD_PATTERN","PARAMETER_PATTERN","parse","path","match","keys","exec","push","compile","exact","RegExp","MATCH_TRAILING_QUERY","execute","pattern","slice","values","a","b","v","i","zip","reduce","acc","key","Path","matched","source","target","length","empty","create","always","freeze","str","decodeURIComponent","record","component","redirect","slot","guard","properties","children","super","customElements","child","parent","normalize","Route","createChildRoute","cache","o","HTMLElement","isPrototypeOf","ctor","default","pathname","search","hash","parameters","toMap","decode","query","WeakMap","h","history","EventEmitter","onPopstate","bind","window","addEventListener","removeEventListener","location","emit","options","data","title","pushState","document","replaceState","n","go","records","isConnected","elements","activeRoutes","routes","History","on","root","to","connect","render","undefined","teardown","disconnect","pop","route","find","r","matches","redirected","transfer","matchedRoutes","load","Promise","all","import","startIndex","Math","min","removals","element","parentElement","removeChild","additions","Component","concat","setAttribute","appendChild","updateProperties","tagName","toLowerCase","snapshot","value","hasOwnProperty","onClick","onChange","router","define","getAttribute","toggleAttribute","active","hasAttribute","disabled","RouterLink","attr","oldValue","newValue","off","querySelector","href","name","predicate","removeAttribute","startsWith","endsWith","event","metaKey","altKey","ctrlKey","shiftKey","defaultPrevented","button","preventDefault"],"mappings":"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"}