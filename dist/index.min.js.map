{"version":3,"file":"index.min.js","sources":["../src/event-emitter.ts","../src/utils.ts","../src/path.ts","../src/query.ts","../src/route.ts","../src/router.ts","../src/router-link.ts"],"sourcesContent":["export type Listener = (detail?: any) => void;\r\n\r\nexport default class EventEmitter {\r\n  map: Map<string, Set<Listener>>;\r\n\r\n  constructor() {\r\n    this.map = new Map();\r\n  }\r\n\r\n  on(type: string, listener: Listener) {\r\n    let listeners;\r\n    if (!this.map.has(type)) {\r\n      listeners = new Set();\r\n      this.map.set(type, listeners);\r\n    } else {\r\n      listeners = this.map.get(type);\r\n    }\r\n    listeners!.add(listener);\r\n  }\r\n\r\n  off(type: string, listener: Listener) {\r\n    if (!this.map.has(type)) {\r\n      return;\r\n    }\r\n\r\n    const listeners = this.map.get(type);\r\n    listeners!.delete(listener);\r\n  }\r\n\r\n  emit(type: string, detail?: any) {\r\n    if (!this.map.has(type)) {\r\n      return;\r\n    }\r\n\r\n    const listeners = this.map.get(type);\r\n    for (const listener of listeners!) {\r\n      listener(detail);\r\n    }\r\n  }\r\n}","/**\r\n * Append a leading slash, and remove all excess slashes.\r\n */\r\nexport function normalize(path: string): string {\r\n  return ('/' + path).replace(/[\\/]+/g, '/');\r\n}\r\n\r\nexport function decode(str: string): string {\r\n  return decodeURIComponent(str);\r\n}\r\n\r\ntype URI = { pathname: string, search: string, hash: string };\r\n\r\nexport function split(path: string): URI {\r\n  let temp = path.split('#');\r\n  const hash = temp[1] || '';\r\n  temp = (temp[0] || '').split('?');\r\n  const search = temp[1] || '';\r\n  const pathname = temp[0] || '';\r\n  return {\r\n    pathname,\r\n    search,\r\n    hash\r\n  };\r\n}\r\n\r\nexport function pathname(path: string): string {\r\n  return (path.split('#')[0] || '').split('?')[0];\r\n}\r\n\r\nexport function search(path: string): string {\r\n  path = (path.split('#')[0] || '');\r\n  if (/\\?/.test(path)) {\r\n    return path.split('?')[1] || '';\r\n  } else {\r\n    return path;\r\n  }\r\n}\r\n\r\nexport function hash(path: string): string {\r\n  return path.split('#')[1] || '';\r\n}\r\n\r\n/**\r\n * Determines if the given object is a callable function.\r\n * An ES2015 class will return false, while ordinary functions,\r\n * arrow functions, generator functions and async functions return true.\r\n * @param object the object that is to be inspected\r\n * @returns `true` if the given object is a callable function\r\n */\r\nexport function isFunction(object: any): boolean {\r\n  if (!(typeof object === 'function')) {\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Values for `hasOwnProperty` on functions:\r\n   * \r\n   *           | Class | Ordinary | Arrow | Async | Generator |\r\n   * ---------------------------------------------------------|\r\n   * arguments | false |   true   | false | false |   false   |\r\n   * prototype | true  |   true   | false | false |   true    |\r\n   * \r\n   */\r\n\r\n  const tag = object[Symbol.toStringTag];\r\n  if (tag === 'AsyncFunction' || tag === 'GeneratorFunction') {\r\n    return true;\r\n  } else {\r\n    // Ordinary functions have an `arguments` property, which classes do not.\r\n    const isNormalFunction = object.hasOwnProperty('arguments');\r\n    // Arrow functions do not have a `prototype` property, which classes do.\r\n    const isArrowFunction = !object.hasOwnProperty('prototype');\r\n    return isNormalFunction || isArrowFunction;\r\n  }\r\n}\r\n\r\nexport function isPromise(object: any): boolean {\r\n  return object[Symbol.toStringTag] === 'Promise';\r\n}\r\n\r\nexport function clone<T>(object: T): T {\r\n  return Object.assign({}, object);\r\n}\r\n\r\nexport function freeze<T>(object: T): T {\r\n  return Object.freeze(object);\r\n}\r\n\r\nexport function empty() {\r\n  return Object.create(null);\r\n}\r\n\r\nexport function always(): true {\r\n  return true;\r\n}\r\n\r\nexport function never(): false {\r\n  return false;\r\n}\r\n\r\nexport function zip(a: any[], b: any[]): any[] {\r\n  return a.map((v, i) => [v, b[i]]);\r\n}\r\n\r\nexport function dict(pairs: [any, any][]): Dictionary<string> {\r\n  let index = -1;\r\n  const length = pairs.length;\r\n  const result: Dictionary<string> = {};\r\n\r\n  while (++index < length) {\r\n    const pair = pairs[index];\r\n    result[pair[0]] = pair[1];\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport const EMPTY = freeze(Object.create(null));\r\n","import { pathname, zip, dict } from './utils';\r\n\r\nconst MATCH_ALL = '[^/]*';\r\n\r\nconst CATCH_ALL = '([^/]+)';\r\n\r\nconst PARAMETER_PATTERN = /:([^\\/]+)/;\r\n\r\n// optional trailing slash\r\n// only matches the slash if nothing follows\r\nconst MATCH_TRAILING_SLASH = '(?:[\\/]?(?=$))?';\r\n\r\n// implements '**' as a wildcard\r\nconst WILDCARD_PATTERN = /\\*\\*/g;\r\n\r\nexport class Path {\r\n  path: string;\r\n  exact: boolean;\r\n  pattern: RegExp;\r\n  keys: string[];\r\n\r\n  constructor(path: string = '', exact: boolean = false) {\r\n    path = pathname(path);\r\n    this.path = path;\r\n    this.exact = exact;\r\n    // replace any wildcards with\r\n    // their corresponding expression\r\n    let temporary = path.replace(WILDCARD_PATTERN, MATCH_ALL);\r\n\r\n    let match: RegExpExecArray | null;\r\n    let keys: string[] = [];\r\n    // convert :param to a catch-all group\r\n    // and save the keys\r\n    while ((match = PARAMETER_PATTERN.exec(temporary)) != null) {\r\n      // match[0] is the entire declaration, e. g. ':param'\r\n      temporary = temporary.replace(match[0], CATCH_ALL);\r\n      // match[1] is the name of the parameter, e. g. 'param'\r\n      keys.push(match[1]);\r\n    }\r\n\r\n    if (!temporary.endsWith('/')) {\r\n      temporary += MATCH_TRAILING_SLASH;\r\n    }\r\n\r\n    temporary = exact ? `^${temporary}$` : `^${temporary}`;\r\n    const pattern = new RegExp(temporary, 'i');\r\n\r\n    this.keys = keys;\r\n    this.pattern = pattern;\r\n  }\r\n\r\n  /**\r\n   * Convenience function that mirrors RegExp.test\r\n   */\r\n  matches(path: string): boolean {\r\n    return this.pattern.test(pathname(path));\r\n  }\r\n\r\n  /**\r\n   * Find the matched part of the given path.\r\n   */\r\n  matched(path: string): string {\r\n    let matched = this.pattern.exec(pathname(path));\r\n    return matched && matched[0] || '';\r\n  }\r\n\r\n  /**\r\n   * Parse a path string for parameter values.\r\n   */\r\n  parse(path: string): Parameters {\r\n    return new Parameters(\r\n      path,\r\n      this.pattern,\r\n      this.keys\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Transfer matched parameters in the given url to\r\n   * the target path, filling in named parameters in if they exist.\r\n   */\r\n  transfer(from: string, to: string): string {\r\n    const values = (this.pattern.exec(from) || []).slice(1);\r\n    let transferred = to;\r\n    let i = values.length;\r\n    while (i--) {\r\n      transferred = transferred\r\n        .replace(':' + this.keys[i], values[i]);\r\n    }\r\n\r\n    return transferred;\r\n  }\r\n}\r\n\r\nexport default Path;\r\n\r\nexport class Parameters extends Map<string, string> {\r\n  path: string;\r\n\r\n  constructor(path: string, pattern: RegExp, keys: string[]) {\r\n    path = pathname(path);\r\n    const values = (pattern.exec(path) || []).slice(1);\r\n    super(zip(keys, values));\r\n    this.path = path;\r\n  }\r\n\r\n  all(): Dictionary<string> {\r\n    return dict(Array.from(this.entries()));\r\n  }\r\n}\r\n","import { search, dict } from './utils';\r\n\r\nexport class Query extends Map<string, string> {\r\n  static from(object: Dictionary): Query {\r\n    return new Query(Object.entries(object));\r\n  }\r\n\r\n  static parse(string: string): Query {\r\n    const queryString = search(string);\r\n\r\n    let entries: Tuple<string>[] = [];\r\n    if (queryString !== '') {\r\n      entries = queryString.split('&')\r\n        .map((substring) => (substring.split('=') as Tuple<string>));\r\n    }\r\n\r\n    return new Query(entries);\r\n  }\r\n\r\n  all(): Dictionary<string> {\r\n    return dict(Array.from(this.entries()));\r\n  }\r\n\r\n  toString(): string {\r\n    let string = '';\r\n    for (const [key, value] of this) {\r\n      string += `&${key}=${value}`;\r\n    }\r\n    return string.substring(1);\r\n  }\r\n}\r\n\r\nexport default Query;\r\n","import Path, { Parameters } from './path';\r\nimport Query from './query';\r\nimport {\r\n  normalize,\r\n  decode,\r\n  split,\r\n  clone,\r\n  freeze,\r\n  always,\r\n  empty,\r\n  isFunction\r\n} from './utils';\r\n\r\nexport interface Module {\r\n  default: HTMLElement;\r\n}\r\n\r\nexport type Component = AsyncComponent | HTMLElement | string;\r\nexport type AsyncComponent = () => Promise<HTMLElement | Module>;\r\nexport type Guard = () => boolean;\r\nexport type Properties = (snapshot: Snapshot) => Dictionary;\r\n\r\nexport interface Record {\r\n  path: string;\r\n  component: Component;\r\n  exact?: boolean;\r\n  redirect?: string;\r\n  slot?: string;\r\n  guard?: Guard;\r\n  properties?: Properties;\r\n  children?: Record[];\r\n}\r\n\r\nexport interface Snapshot {\r\n  readonly parameters: Parameters;\r\n  readonly query: Query;\r\n  readonly hash: string;\r\n  readonly matched: string;\r\n}\r\n\r\nexport interface Location {\r\n  search: string;\r\n  hash: string;\r\n  pathname: string;\r\n}\r\n\r\nexport class Route extends Path {\r\n  static cache = new Map();\r\n  path: string;\r\n  exact: boolean;\r\n  component: Component;\r\n  children: Route[];\r\n  redirect?: string;\r\n  slot?: string;\r\n  guard: Guard;\r\n  properties: Properties;\r\n\r\n  static async import(identifier: Component): Promise<HTMLElement> {\r\n    if (typeof identifier === 'string') {\r\n      // If it's a string, assume that it has\r\n      // been defined, and return the constructor\r\n      // from the element registry\r\n      return customElements.get(identifier);\r\n  \r\n    } else if (isFunction(identifier)) {\r\n      // If it's a function, call it\r\n      let called = (identifier as AsyncComponent)();\r\n      // If it's a promise, resolve it\r\n      let resolved = await Promise.resolve(called);\r\n\r\n      // If the promise resolved directly to an element,\r\n      // return it\r\n      // otherwise, assume that it resolved to a module\r\n      // with the default export being the element\r\n      if ((resolved as Module).default) {\r\n        return (resolved as Module).default;\r\n      } else {\r\n        return resolved as HTMLElement;\r\n      }\r\n    } else {\r\n      // If it's not a string or a promise,\r\n      // it's just\r\n      return identifier as HTMLElement;\r\n    }\r\n  }\r\n\r\n  constructor(record: Record) {\r\n    let {\r\n      path,\r\n      component,\r\n      exact,\r\n      redirect,\r\n      slot,\r\n      guard,\r\n      properties,\r\n      children\r\n    } = record;\r\n\r\n    // Path should be exact if the route\r\n    // does not have any children,\r\n    // but only if the record does not\r\n    // declare anything\r\n    if (exact == null) {\r\n      exact = (\r\n        children == null ||\r\n        children.length === 0\r\n      );\r\n    }\r\n\r\n    super(path, exact);\r\n    this.path = path;\r\n    this.exact = exact;\r\n    this.redirect = redirect;\r\n    this.component = component;\r\n    this.slot = slot;\r\n    this.guard = guard || always;\r\n    this.properties = freeze(properties || empty);\r\n    this.children = (children || []).map(child =>\r\n      createChildRoute(clone(child), this)\r\n    );\r\n  }\r\n\r\n  async import(): Promise<HTMLElement> {\r\n    if (Route.cache.has(this.component)) {\r\n      return Route.cache.get(this.component);\r\n    } else {\r\n      let ctor = await Route.import(this.component);\r\n      Route.cache.set(this.component, ctor);\r\n      return ctor;\r\n    }\r\n  }\r\n\r\n  snapshot(identifier: string | Location): Snapshot {\r\n    let uri;\r\n    if (typeof identifier === 'string') {\r\n      uri = split(identifier);\r\n    } else {\r\n      uri = identifier;\r\n    }\r\n\r\n    return freeze({\r\n      parameters: this.parse(decode(uri.pathname)),\r\n      query: Query.parse(decode(uri.search)),\r\n      matched: this.matched(decode(uri.pathname)),\r\n      hash: uri.hash\r\n    });\r\n  }\r\n}\r\n\r\nfunction createChildRoute(record: Record, parent: Route): Route {\r\n  if (record.path === '') {\r\n    // If the path is empty, simply copy the parent path\r\n    record.path = parent.path;\r\n  } else {\r\n    // Otherwise, prepend the parent path\r\n    record.path = normalize(parent.path + '/' + record.path);\r\n  }\r\n\r\n  // Same idea with redirect\r\n  if (record.redirect != null) {\r\n    if (record.redirect === '') {\r\n      record.redirect = parent.path;\r\n    } else {\r\n      record.redirect = normalize(parent.path + '/' + record.redirect);\r\n    }\r\n  }\r\n\r\n  return new Route(record);\r\n}\r\n\r\nexport default Route;","import EventEmitter from './event-emitter';\r\nimport Route, { Record } from './route';\r\nimport { EMPTY, decode, pathname } from './utils';\r\n\r\nexport interface SearchResult {\r\n  matched: Route[];\r\n  path: string;\r\n}\r\n\r\nexport interface NavigationOptions {\r\n  data: any;\r\n  title: string;\r\n}\r\n\r\nexport class Router extends EventEmitter {\r\n  static instance: Router;\r\n  elements: HTMLElement[];\r\n  matched: Route[];\r\n  routes: Route[];\r\n  isConnected: boolean;\r\n  target?: HTMLElement;\r\n\r\n  constructor(records: Record[]) {\r\n    super();\r\n    this.isConnected = false;\r\n    this.elements = [];\r\n    this.matched = [];\r\n    this.routes = records.map(record => new Route(record));\r\n    this.onPopstate = this.onPopstate.bind(this);\r\n    Router.instance = this;\r\n  }\r\n\r\n  async connect(target: HTMLElement): Promise<void> {\r\n    this.isConnected = true;\r\n    this.target = target;\r\n    window.addEventListener('popstate', this.onPopstate);\r\n    const currentPath = decode(location.pathname);\r\n    const { matched, path } = this.match(currentPath);\r\n\r\n    history.replaceState(history.state, document.title, path);\r\n    await this.render(matched);\r\n    this.emit('connect');\r\n  }\r\n\r\n  disconnect(): void {\r\n    this.isConnected = false;\r\n    window.removeEventListener('popstate', this.onPopstate);\r\n    this.teardown();\r\n    this.matched = [];\r\n    this.target = undefined;\r\n    this.emit('disconnect');\r\n  }\r\n\r\n  onPopstate(): void {\r\n    const to = decode(location.pathname);\r\n    const { matched, path } = this.match(to);\r\n    if (to !== path) {\r\n      history.replaceState(history.state, document.title, path);\r\n    }\r\n    this.emit('pop');\r\n    this.render(matched);\r\n  }\r\n\r\n  push(to: string, options: NavigationOptions = EMPTY): Promise<void> {\r\n    to = decode(to);\r\n    const { matched, path } = this.match(to);\r\n    const { data, title } = options;\r\n    history.pushState(data, title, path);\r\n    this.emit('push');\r\n    return this.render(matched);\r\n  }\r\n\r\n  replace(to: string, options: NavigationOptions = EMPTY): Promise<void> {\r\n    to = decode(to);\r\n    const { matched, path } = this.match(to);\r\n    const { data, title } = options;\r\n    history.replaceState(data, title, path);\r\n    this.emit('replace');\r\n    return this.render(matched);\r\n  }\r\n\r\n  go(entries: number) {\r\n    // triggers onPopstate(), so no need to render\r\n    // in this method call\r\n    history.go(entries);\r\n  }\r\n\r\n  search(path: string, routes: Route[], matched: Route[]): SearchResult {\r\n    const route = routes\r\n      .find(r => r.matches(path) && r.guard());\r\n\r\n    if (route) {\r\n      matched.push(route);\r\n      if (route.redirect) {\r\n        // transfer any matched parameters\r\n        const from = route.matched(pathname(path));\r\n        const to = route.redirect;\r\n        const redirected = route.transfer(from, to);\r\n        // and start over\r\n        return this.search(redirected, this.routes, []);\r\n      } else if (route.children) {\r\n        // Search through the children\r\n        return this.search(path, route.children, matched);\r\n      } else {\r\n        return { matched, path };\r\n      }\r\n    } else {\r\n      // End the search here\r\n      return { matched, path };\r\n    }\r\n  }\r\n\r\n  match(path: string): SearchResult {\r\n    return this.search(path, this.routes, []);\r\n  }\r\n\r\n  async render(matched: Route[]) {\r\n    if (this.target == undefined) {\r\n      return;\r\n    }\r\n\r\n    // Importing early in case both network\r\n    // and device is slow, but not awaiting\r\n    // it just yet.\r\n    const load = Promise.all(\r\n      matched.map(route => route.import())\r\n    );\r\n\r\n    // Find the index at which the matched routes\r\n    // differ from the active routes.\r\n    let start;\r\n    for (let i = 0; i < matched.length; i++) {\r\n      const match = matched[i];\r\n      if (this.matched.length < i + 1) {\r\n        start = i;\r\n        break;\r\n      } else {\r\n        const active = this.matched[i];\r\n        if (match !== active) {\r\n          start = i;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (start == null) {\r\n      start = matched.length;\r\n    }\r\n\r\n    this.matched = matched;\r\n\r\n    // Remove the obsolete elements\r\n    const removals = this.elements.slice(start);\r\n    while (removals.length > 0) {\r\n      const element = removals.pop();\r\n      element!.remove();\r\n    }\r\n\r\n    this.elements = this.elements.slice(0, start);\r\n\r\n    const components = await load;\r\n    // Create the new elements\r\n    const additions = components.slice(start)\r\n      // TODO: fix type\r\n      .map((Component: any) => new Component());\r\n\r\n    // Combine the newly created elements in order\r\n    // while being careful not to render them yet\r\n    for (let i = 0; i < additions.length - 1; i++) {\r\n      const parent = additions[i];\r\n      const child = additions[i + 1];\r\n      parent.appendChild(child);\r\n    }\r\n\r\n    this.elements = this.elements.concat(additions);\r\n\r\n    // In correct order, resolve any new properties\r\n    // Note: this happens before the new elements are connected\r\n\r\n    for (let i = 0; i < this.elements.length; i++) {\r\n      // TODO: fix type\r\n      const element: any = this.elements[i];\r\n      const route = matched[i];\r\n      // TODO: fix type\r\n      const Component: any = components[i];\r\n      const options = Component.properties;\r\n      if (options != undefined) {\r\n        const snapshot = route.snapshot(location);\r\n        const parameters = snapshot.parameters;\r\n        // Resolve parameters from paths\r\n        for (const [key, value] of parameters) {\r\n          if (options.hasOwnProperty(key)) {\r\n            element[key] = value;\r\n          }\r\n        }\r\n\r\n        // Resolve additional properties from route\r\n        const properties = route.properties(snapshot);\r\n        for (const key in properties) {\r\n          if (options.hasOwnProperty(key)) {\r\n            const value = properties[key];\r\n            element[key] = value;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (route.slot) {\r\n        element.setAttribute('slot', route.slot);\r\n      }\r\n    }\r\n\r\n    // If there are any additions, they need to be rendered\r\n    if (additions.length > 0) {\r\n      if (start > 0) {\r\n        // Some reuse\r\n        // Connect the new elements to the deepest reused element,\r\n        // implicitly rendering them\r\n        this.elements[start - 1].appendChild(additions[0]);\r\n      } else {\r\n        // No reuse\r\n        this.target.appendChild(this.elements[0]);\r\n      }\r\n    }\r\n\r\n    this.emit('render');\r\n  }\r\n\r\n  teardown() {\r\n    while (this.elements.length > 0) {\r\n      const element = this.elements.pop();\r\n      element!.remove();\r\n    }\r\n  }\r\n}\r\n\r\nexport default Router;\r\n","import Router from './router';\r\n\r\nexport class RouterLink extends HTMLElement {\r\n  static observedAttributes = ['disabled'];\r\n  static tagName = 'router-link';\r\n  router: Router;\r\n\r\n  static install() {\r\n    customElements.define(this.tagName, this);\r\n  }\r\n\r\n  constructor() {\r\n    super();\r\n    this.router = Router.instance;\r\n    this.onClick = this.onClick.bind(this);\r\n    this.onChange = this.onChange.bind(this);\r\n  }\r\n\r\n  get anchor() {\r\n    return this.querySelector('a');\r\n  }\r\n\r\n  set to(v: string) {\r\n    this.anchor!.href = v;\r\n    const path = decodeURIComponent(location.pathname);\r\n    this.active = this.match(path);\r\n  }\r\n\r\n  get to(): string {\r\n    return decodeURIComponent(this.anchor!.pathname);\r\n  }\r\n\r\n  set exact(v: boolean) {\r\n    this.toggleAttribute('exact', v);\r\n    const path = decodeURIComponent(location.pathname);\r\n    this.active = this.match(path);\r\n  }\r\n\r\n  get exact(): boolean {\r\n    return this.hasAttribute('exact');\r\n  }\r\n\r\n  set active(v: boolean) {\r\n    this.toggleAttribute('active', v);\r\n  }\r\n\r\n  get active(): boolean {\r\n    return this.hasAttribute('active');\r\n  }\r\n\r\n  set disabled(v: boolean) {\r\n    this.toggleAttribute('disabled', v);\r\n  }\r\n\r\n  get disabled(): boolean {\r\n    return this.hasAttribute('disabled');\r\n  }\r\n\r\n  attributesChangedCallback(attr: string, oldValue: string, newValue: string) {\r\n    if (attr === 'disabled') {\r\n      const hasValue = newValue != null;\r\n      if (hasValue) {\r\n        this.active = false;\r\n        this.router.off('render', this.onChange);\r\n      } else {\r\n        this.router.on('render', this.onChange);\r\n        this.onChange();\r\n      }\r\n    }\r\n  }\r\n\r\n  connectedCallback() {\r\n    this.addEventListener('click', this.onClick);\r\n    this.router.on('render', this.onChange);\r\n    this.onChange();\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    this.removeEventListener('click', this.onClick);\r\n    this.router.off('render', this.onChange);\r\n  }\r\n\r\n  toggleAttribute(name: string, predicate: boolean) {\r\n    if (predicate) {\r\n      this.setAttribute(name, '');\r\n    } else {\r\n      this.removeAttribute(name);\r\n    }\r\n  }\r\n\r\n  match(path: string): boolean {\r\n    const to = this.to;\r\n    if (to.startsWith('/')) {\r\n      return this.exact\r\n        ? path === to\r\n        : path.startsWith(to);\r\n    } else {\r\n      return path.endsWith(to);\r\n    }\r\n  }\r\n\r\n  onClick(event: MouseEvent) {\r\n    // Ignore clicks with modifiers\r\n    if (\r\n      event.metaKey ||\r\n      event.altKey ||\r\n      event.ctrlKey ||\r\n      event.shiftKey\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    // Ignore prevented clicks\r\n    if (event.defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    // Ignore right mouse button clicks\r\n    if (\r\n      event.button !== undefined &&\r\n      event.button !== 0\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    event.preventDefault();\r\n    const to = this.to;\r\n    if (this.disabled || !to) {\r\n      return;\r\n    } else {\r\n      this.router.push(to);\r\n    }\r\n  }\r\n\r\n  onChange() {\r\n    const path = decodeURIComponent(location.pathname);\r\n    this.active = this.match(path);\r\n  }\r\n}\r\n\r\nexport default RouterLink;\r\n"],"names":["[object Object]","this","map","Map","type","listener","listeners","has","get","Set","set","add","delete","detail","path","replace","str","decodeURIComponent","temp","split","hash","search","pathname","test","object","tag","Symbol","toStringTag","isNormalFunction","hasOwnProperty","isArrowFunction","Object","assign","freeze","create","a","b","v","i","pairs","index","length","result","pair","EMPTY","MATCH_ALL","CATCH_ALL","PARAMETER_PATTERN","MATCH_TRAILING_SLASH","WILDCARD_PATTERN","exact","match","temporary","keys","exec","push","endsWith","pattern","RegExp","matched","Parameters","from","to","values","slice","transferred","super","zip","dict","Array","entries","Query","string","queryString","substring","key","value","Path","record","component","redirect","slot","guard","properties","children","always","empty","child","createChildRoute","clone","identifier","customElements","isFunction","called","resolved","Promise","resolve","default","Route","cache","ctor","import","uri","parameters","parse","decode","query","parent","normalize","EventEmitter","records","isConnected","elements","routes","onPopstate","bind","Router","instance","target","window","addEventListener","currentPath","location","history","replaceState","state","document","title","render","emit","removeEventListener","teardown","undefined","options","data","pushState","go","route","find","r","matches","redirected","transfer","load","all","start","removals","pop","remove","components","additions","Component","appendChild","concat","element","snapshot","setAttribute","HTMLElement","router","onClick","onChange","define","tagName","anchor","querySelector","href","active","toggleAttribute","hasAttribute","disabled","attr","oldValue","newValue","off","on","name","predicate","removeAttribute","startsWith","event","metaKey","altKey","ctrlKey","shiftKey","defaultPrevented","button","preventDefault","RouterLink"],"mappings":"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"}