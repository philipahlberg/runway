{"version":3,"file":"index.min.js","sources":["../src/path.js","../src/query.js","../src/utils.js","../src/route.js","../src/router.js"],"sourcesContent":["const MATCH_ALL = '[^/]*';\r\n\r\nconst CATCH_ALL = '([^/]+)';\r\n\r\nconst PARAMETER_PATTERN = /:([^\\/]+)/;\r\n\r\n// optional trailing slash\r\n// only matches the slash if nothing follows\r\nconst MATCH_TRAILING_SLASH = '(?:[\\/]?(?=$))?';\r\n\r\n// implements '**' as a wildcard\r\nconst WILDCARD_PATTERN = /\\*\\*/g;\r\n\r\nexport class Path {\r\n  /**\r\n   * \r\n   * @param {String} input The path to compile\r\n   * @param {Boolean} exact Whether or not the pattern should match anything after the path\r\n   */\r\n  constructor(path, exact = false) {\r\n    // replace any wildcards with\r\n    // their corresponding expression\r\n    path = path.replace(WILDCARD_PATTERN, MATCH_ALL);\r\n    \r\n    let match;\r\n    let keys = [];\r\n    // convert :param to a catch-all group\r\n    // and save the keys\r\n    while ((match = PARAMETER_PATTERN.exec(path)) != null) {\r\n      path = path.replace(match[0], CATCH_ALL);\r\n      keys.push(match[1]);\r\n    }\r\n\r\n    if (!path.endsWith('/')) {\r\n      path += MATCH_TRAILING_SLASH;\r\n    }\r\n\r\n    path = exact ? `^${path}$` : `^${path}`;\r\n    const pattern = new RegExp(path, 'i');\r\n\r\n    this.pattern = pattern;\r\n    this.keys = keys;\r\n  }\r\n\r\n  /**\r\n   * Convenience function that mirrors RegExp.test\r\n   * @param {String} path\r\n   * @return {Boolean} \r\n   */\r\n  matches(path) {\r\n    return this.pattern.test(path);\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {String} path Path to match against.\r\n   * @return {String} Matched portion of the path. \r\n   */\r\n  matched(path) {\r\n    return this.pattern.exec(path)[0];\r\n  }\r\n\r\n  /**\r\n   * @param {String} url The path to get values from\r\n   * @return {ParsedExpression} A collection of functions for working with the url\r\n   */\r\n  parse(url) {\r\n    return new ParsedExpression(\r\n      url,\r\n      this.pattern,\r\n      this.keys\r\n    );\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {String} target A path, potentially with unresolved parameters \r\n   * @param {String} current The path that was matched\r\n   * @return {String} The target path with parameters filled in\r\n   */\r\n  transfer(current, target) {\r\n    const values = this.pattern.exec(current).slice(1);\r\n    let transferred = target;\r\n\r\n    let i = values.length;\r\n    while (i--) {\r\n      transferred = transferred\r\n        .replace(':' + this.keys[i], values[i]);\r\n    }\r\n\r\n    return transferred;\r\n  }\r\n}\r\n\r\nclass ParsedExpression {\r\n  constructor(url, pattern, keys) {\r\n    this.values = pattern.exec(url).slice(1);\r\n    this.url = url;\r\n    this.keys = keys;\r\n    this.map = new Map();\r\n  }\r\n\r\n  get(key) {\r\n    return this.values[this.keys.indexOf(key)];\r\n  }\r\n\r\n  set(key, value) {\r\n    return this.url.replace(this.get(key), value);\r\n  }\r\n\r\n  has(key) {\r\n    return this.get(key) !== undefined;\r\n  }\r\n\r\n  all() {\r\n    return this.keys.reduce((object, key, i) => {\r\n      object[key] = this.values[i];\r\n      return object;\r\n    }, {});\r\n  }\r\n\r\n  entries() {\r\n    let entries = [];\r\n    for (let i = 0; i < this.keys.length; i++) {\r\n      entries.push([this.keys[i], this.values[i]]);\r\n    }\r\n  }\r\n\r\n  *[Symbol.iterator]() {\r\n    const length = this.keys.length;\r\n    for (let i = 0; i < length; i++) {\r\n      yield [this.keys[i], this.values[i]];\r\n    }\r\n  }\r\n}\r\n\r\nexport default Path;","export class Query extends Map {\r\n  static from(object) {\r\n    return new Query(Object.entries(object));\r\n  }\r\n\r\n  static of(...pairs) {\r\n    return new Query(pairs);\r\n  }\r\n\r\n  static parse(string) {\r\n    if (string.startsWith('?')) {\r\n      string = string.substring(1);\r\n    }\r\n\r\n    let entries = [];\r\n    if (string !== '') {\r\n      entries = string.split('&')\r\n        .map((substring) => substring.split('='));\r\n    }\r\n\r\n    return new Query(entries);\r\n  }\r\n\r\n  toString() {\r\n    let string = '';\r\n    for (const [key, value] of this) {\r\n      string += `&${key}=${value}`;\r\n    }\r\n    return string.substring(1);\r\n  }\r\n}","/**\r\n * Append a leading slash, and remove all excess slashes.\r\n * @param {string} path\r\n * @returns {string}\r\n */\r\nexport function normalize(path) {\r\n  return ('/' + path).replace(/[\\/]+/g, '/');\r\n}\r\n\r\n/**\r\n * Determines if the given object is a callable function.\r\n * An ES2015 class will return false, while ordinary functions,\r\n * arrow functions, generator functions and async functions return true.\r\n * @param {object} object the object that is to be inspected\r\n * @returns {boolean} if the given object is a callable function\r\n */\r\nexport function isFunction(object) {\r\n  if (!(typeof object === 'function')) {\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Truthiness matrix for `hasOwnProperty` on functions:\r\n   * \r\n   *           | Class | Ordinary | Arrow | Async | Generator |\r\n   * ---------------------------------------------------------|\r\n   * arguments | false |   true   | false | false |   false   |\r\n   * prototype | true  |   true   | false | false |   true    |\r\n   * \r\n   */\r\n\r\n  const tag = object[Symbol.toStringTag];\r\n  if (tag === 'AsyncFunction' || tag === 'GeneratorFunction') {\r\n    return true;\r\n  } else {\r\n    // Ordinary functions have an `arguments` property, which classes do not.\r\n    const isNormalFunction = object.hasOwnProperty('arguments');\r\n    // Arrow functions do not have a `prototype` property, which classes do.\r\n    const isArrowFunction = !object.hasOwnProperty('prototype');\r\n    return isNormalFunction || isArrowFunction;\r\n  }\r\n}\r\n\r\nexport function isPromise(object) {\r\n  return object[Symbol.toStringTag] === 'Promise';\r\n}\r\n\r\nconst components = new WeakMap();\r\n\r\n/**\r\n * Resolve an identifier to a class.\r\n * @param {Promise|Function|String} component The identifier\r\n * @param {Function} callback\r\n */\r\nexport function load(component, callback) {\r\n  if (typeof component === 'string') {\r\n    // If it's a string, assume that it has\r\n    // been defined, and return the class\r\n    // associated with the tag to allow\r\n    // uniform callback function signature.\r\n    callback(customelements.get(component));\r\n\r\n  } else if (components.has(component)) {\r\n    // If it has been resolved before,\r\n    // return the resolved value.\r\n    callback(components.get(component));\r\n\r\n  } else if (isFunction(component)) {\r\n    // If it's a function, call it.\r\n    let called = component();\r\n    if (isPromise(called)) {\r\n      // If the function returns a promise,\r\n      // assume that it is a module and assume\r\n      // the component is the default export.\r\n      called.then((m) => {\r\n        components.set(component, m.default);\r\n        callback(m.default);\r\n      });\r\n    } else {\r\n      // If the function call returned something\r\n      // that isn't a promise, assume that it returned\r\n      // a component directly.\r\n      components.set(component, called);\r\n      callback(called);\r\n    }\r\n  } else {\r\n    callback(component);\r\n  }\r\n}\r\n","import { Path } from './path.js';\r\nimport { Query } from './query.js';\r\nimport { load, normalize, isFunction, isPromise } from './utils.js';\r\n\r\nconst clone = (obj) => Object.assign({}, obj);\r\nconst freeze = (obj) => Object.freeze(obj);\r\n\r\nexport class Route extends Path {\r\n  constructor(options) {\r\n    super(options.path, options.exact);\r\n    this.path = options.path;\r\n    this.exact = options.exact === true;\r\n    this.redirect = options.redirect;\r\n    this.component = options.component;\r\n    this.slot = options.slot;\r\n    this.meta = freeze(options.meta || {});\r\n    this.properties = freeze(options.properties || {});\r\n    this.children = (options.children || [])\r\n      .map(record => createChildRoute(clone(record), this));\r\n  }\r\n\r\n  async import() {\r\n    return new Promise((resolve) => {\r\n      load(this.component, (Component) => resolve(Component));\r\n    });\r\n  }\r\n}\r\n\r\nfunction createChildRoute(record, parent) {\r\n  if (record.path === '') {\r\n    record.path = parent.path;\r\n  } else {\r\n    record.path = normalize(parent.path + '/' + record.path);\r\n  }\r\n\r\n  if (record.redirect != null) {\r\n    if (record.redirect === '') {\r\n      record.redirect = parent.path;\r\n    } else {\r\n      record.redirect = normalize(parent.path + '/' + record.redirect);\r\n    }\r\n  }\r\n\r\n  if (record.children == null) {\r\n    record.exact = true;\r\n  }\r\n\r\n  return new Route(record);\r\n}\r\n\r\nexport class ActiveRoute {\r\n  constructor(route, url) {\r\n    this.parameters = route.parse(url);\r\n    this.matched = route.matched(url);\r\n    this.query = Query.parse(url);\r\n    this.hash = location.hash.substring(1);\r\n  }\r\n}","import { Route, ActiveRoute } from './route.js';\r\n\r\nconst EMPTY = Object.create(null);\r\n\r\nexport default class Router {\r\n  constructor(records, target) {\r\n    this.views = [];\r\n    this.matched = [];\r\n    this.routes = records.map(record => new Route(record));\r\n    this.onPopstate = this.onPopstate.bind(this);\r\n\r\n    window.Router = this;\r\n    \r\n    if (target) {\r\n      this.connect(target);\r\n    }\r\n  }\r\n\r\n  connect(target) {\r\n    this.target = target;\r\n    window.addEventListener('popstate', this.onPopstate);\r\n    const url = decodeURIComponent(location.pathname);\r\n    const { matched } = this.resolve(url);\r\n    return this.render(matched);\r\n  }\r\n\r\n  disconnect() {\r\n    window.removeEventListener('popstate', this.onPopstate);\r\n    while (this.views.length > 0) {\r\n      const view = this.views.pop();\r\n      view.remove();\r\n    }\r\n    this.matched = [];\r\n    this.target = null;\r\n  }\r\n\r\n  onPopstate() {\r\n    const url = decodeURIComponent(location.pathname);\r\n    const { matched } = this.resolve(url);\r\n    this.render(matched);\r\n  }\r\n\r\n  push(path, { data, title } = EMPTY) {\r\n    path = decodeURIComponent(path);\r\n    const { matched, url } = this.resolve(path);\r\n    history.pushState(data, title, url);\r\n    return this.render(matched);\r\n  }\r\n\r\n  replace(path, { data, title } = EMPTY) {\r\n    path = decodeURIComponent(path);\r\n    const { matched, url } = this.resolve(path);\r\n    history.replaceState(data, title, url);\r\n    return this.render(matched);\r\n  }\r\n\r\n  resolve(url) {\r\n    let matched = [];\r\n\r\n    const search = (routes) => {\r\n      // Find a starting match\r\n      const route = routes.find(route => route.matches(url));\r\n      if (route) {\r\n        matched.push(route);\r\n        if (route.redirect) {\r\n          // transfer any matched parameters\r\n          const matched = route.matched(url);\r\n          url = route.transfer(matched, route.redirect);\r\n          // and start over\r\n          return this.resolve(url);\r\n        } else if (route.children) {\r\n          // Search through the children\r\n          return search(route.children);\r\n        } else {\r\n          // End the search here\r\n          return { matched, url };\r\n        }\r\n      } else {\r\n        return { matched, url };\r\n      }\r\n    }\r\n\r\n    return search(this.routes);\r\n  }\r\n\r\n  async render(matched) {\r\n    // Importing early in case both network\r\n    // and device is slow, but not awaiting\r\n    // it just yet.\r\n    const load = Promise.all(\r\n      matched.map(route => route.import())\r\n    );\r\n\r\n    // Find the index at which the matched routes\r\n    // differ from the active routes.\r\n    let start;\r\n    for (let i = 0; i < matched.length; i++) {\r\n      const match = matched[i];\r\n      if (this.matched.length < i + 1) {\r\n        start = i;\r\n        break;\r\n      } else {\r\n        const active = this.matched[i];\r\n        if (match !== active) {\r\n          start = i;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (start == null) {\r\n      start = matched.length;\r\n    }\r\n\r\n    this.matched = matched;\r\n\r\n    // Remove the obsolete elements\r\n    const removals = this.views.slice(start);\r\n    if (removals.length > 0) {\r\n      removals[0].remove();\r\n    }\r\n\r\n    this.views = this.views.slice(0, start);\r\n\r\n    const components = await load;\r\n    // Create the new elements\r\n    const additions = components.slice(start)\r\n      .map(Component => new Component());\r\n\r\n    // Combine the newly created elements in order\r\n    // while being careful not to render them yet\r\n    for (let k = 0; k < additions.length - 1; k++) {\r\n      const parent = additions[k];\r\n      const child = additions[k + 1];\r\n      parent.append(child);\r\n    }\r\n\r\n    this.views = this.views.concat(additions);\r\n\r\n    // In correct order, resolve any new properties\r\n    // Note: this happens before the new elements are connected\r\n    const url = decodeURIComponent(location.pathname);\r\n    for (let k = 0; k < this.views.length; k++) {\r\n      const view = this.views[k];\r\n      const route = matched[k];\r\n      const Component = components[k];\r\n\r\n      const active = new ActiveRoute(route, url);\r\n\r\n      const parameters = active.parameters;\r\n      const options = Component.properties;\r\n      if (options != null) {\r\n        // Resolve parameters from paths\r\n        for (const [key, value] of parameters) {\r\n          if (options.hasOwnProperty(key)) {\r\n            view[key] = value;\r\n          }\r\n        }\r\n\r\n        // Resolve additional properties from route\r\n        for (const key in route.properties) {\r\n          if (options.hasOwnProperty(key)) {\r\n            const value = route.properties[key];\r\n            view[key] = value;\r\n          }\r\n        }\r\n      }\r\n\r\n      view.route = active;\r\n\r\n      if (route.slot) {\r\n        view.setAttribute('slot', route.slot);\r\n      }\r\n    }\r\n\r\n    // If there are any additions, they need to be rendered\r\n    if (additions.length > 0) {\r\n      if (start > 0) {\r\n        // Some reuse\r\n        // Connect the new elements to the deepest reused element,\r\n        // implicitly rendering them\r\n        this.views[start - 1].append(additions[0]);\r\n      } else {\r\n        // No reuse\r\n        this.target.append(this.views[0]);\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"names":["MATCH_ALL","CATCH_ALL","PARAMETER_PATTERN","MATCH_TRAILING_SLASH","WILDCARD_PATTERN","Path","[object Object]","path","exact","match","replace","keys","exec","push","endsWith","pattern","RegExp","this","test","url","ParsedExpression","current","target","values","slice","transferred","i","length","map","Map","key","indexOf","value","get","undefined","reduce","object","entries","Symbol","iterator","Query","Object","pairs","string","startsWith","substring","split","normalize","isFunction","tag","toStringTag","isNormalFunction","hasOwnProperty","isArrowFunction","isPromise","components","WeakMap","load","component","callback","customelements","has","called","then","m","set","default","clone","obj","assign","freeze","Route","options","super","redirect","slot","meta","properties","children","record","createChildRoute","Promise","resolve","Component","parent","ActiveRoute","route","parameters","parse","matched","query","hash","location","EMPTY","create","Router","records","views","routes","onPopstate","bind","window","connect","addEventListener","decodeURIComponent","pathname","render","removeEventListener","pop","remove","data","title","history","pushState","replaceState","search","find","matches","transfer","all","import","start","removals","additions","k","child","append","concat","view","active","setAttribute"],"mappings":"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"}