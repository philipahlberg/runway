{"version":3,"file":"index.min.js","sources":["../src/event-emitter.ts","../src/path.ts","../src/query.ts","../src/utils.ts","../src/route.ts","../src/router.ts"],"sourcesContent":["export type Listener = (detail?: any) => void;\r\n\r\nexport default class EventEmitter {\r\n  map: Map<string, Set<Listener>>;\r\n\r\n  constructor() {\r\n    this.map = new Map();\r\n  }\r\n\r\n  on(type: string, listener: Listener) {\r\n    let listeners;\r\n    if (!this.map.has(type)) {\r\n      listeners = new Set();\r\n      this.map.set(type, listeners);\r\n    } else {\r\n      listeners = this.map.get(type);\r\n    }\r\n    listeners!.add(listener);\r\n  }\r\n\r\n  off(type: string, listener: Listener) {\r\n    if (!this.map.has(type)) {\r\n      return;\r\n    }\r\n\r\n    const listeners = this.map.get(type);\r\n    listeners!.delete(listener);\r\n  }\r\n\r\n  emit(type: string, detail?: any) {\r\n    if (!this.map.has(type)) {\r\n      return;\r\n    }\r\n\r\n    const listeners = this.map.get(type);\r\n    for (const listener of listeners!) {\r\n      listener(detail);\r\n    }\r\n  }\r\n}","const MATCH_ALL = '[^/]*';\r\n\r\nconst CATCH_ALL = '([^/]+)';\r\n\r\nconst PARAMETER_PATTERN = /:([^\\/]+)/;\r\n\r\n// optional trailing slash\r\n// only matches the slash if nothing follows\r\nconst MATCH_TRAILING_SLASH = '(?:[\\/]?(?=$))?';\r\n\r\n// implements '**' as a wildcard\r\nconst WILDCARD_PATTERN = /\\*\\*/g;\r\n\r\nexport class Path {\r\n  path: string;\r\n  exact: boolean;\r\n  pattern: RegExp;\r\n  keys: string[];\r\n\r\n  /**\r\n   * \r\n   * @param input The path to compile\r\n   * @param exact Whether or not the pattern should match anything after the path\r\n   */\r\n  constructor(path: string = '', exact: boolean = false) {\r\n    this.path = path;\r\n    this.exact = exact;\r\n    // replace any wildcards with\r\n    // their corresponding expression\r\n    let temporary = path.replace(WILDCARD_PATTERN, MATCH_ALL);\r\n\r\n    let match: RegExpExecArray | null;\r\n    let keys: string[] = [];\r\n    // convert :param to a catch-all group\r\n    // and save the keys\r\n    while ((match = PARAMETER_PATTERN.exec(temporary)) != null) {\r\n      temporary = temporary.replace(match[0], CATCH_ALL);\r\n      keys.push(match[1]);\r\n    }\r\n\r\n    if (!temporary.endsWith('/')) {\r\n      temporary += MATCH_TRAILING_SLASH;\r\n    }\r\n\r\n    temporary = exact ? `^${temporary}$` : `^${temporary}`;\r\n    const pattern = new RegExp(temporary, 'i');\r\n\r\n    this.keys = keys;\r\n    this.pattern = pattern;\r\n  }\r\n\r\n  /**\r\n   * Convenience function that mirrors RegExp.test\r\n   */\r\n  matches(path: string): boolean {\r\n    return this.pattern.test(path);\r\n  }\r\n\r\n  /**\r\n   * Find the matched part of the given path.\r\n   */\r\n  matched(path: string): string {\r\n    let matched = this.pattern.exec(path);\r\n    return matched && matched[0] || '';\r\n  }\r\n\r\n  /**\r\n   * Parse a path string for parameter values.\r\n   */\r\n  parse(path: string): Parameters {\r\n    return new Parameters(\r\n      path,\r\n      this.pattern,\r\n      this.keys\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Transfer matched parameters in the given url to\r\n   * the target path, filling in named parameters in if they exist.\r\n   * @param {String} from a matched url\r\n   * @param {String} to a path\r\n   * @return {String} The target path with parameters filled in\r\n   */\r\n  transfer(from: string, to: string): string {\r\n    const values = (this.pattern.exec(from) || []).slice(1);\r\n    let transferred = to;\r\n    let i = values.length;\r\n    while (i--) {\r\n      transferred = transferred\r\n        .replace(':' + this.keys[i], values[i]);\r\n    }\r\n\r\n    return transferred;\r\n  }\r\n}\r\n\r\nexport type Dictionary = { [key: string]: string };\r\nexport type Tuple<T> = [T, T];\r\n\r\nexport class Parameters {\r\n  path: string;\r\n  keys: string[];\r\n  values: string[];\r\n\r\n  constructor(path: string, pattern: RegExp, keys: string[]) {\r\n    this.path = path;\r\n    this.keys = keys;\r\n    this.values = (pattern.exec(path) || []).slice(1);\r\n  }\r\n\r\n  get(key: string): string {\r\n    return this.values[this.keys.indexOf(key)];\r\n  }\r\n\r\n  set(key: string, value: string): string {\r\n    return this.path.replace(this.get(key), value);\r\n  }\r\n\r\n  has(key: string): boolean {\r\n    return this.get(key) !== undefined;\r\n  }\r\n\r\n  entries(): Tuple<string>[] {\r\n    let entries: Tuple<string>[] = [];\r\n    for (let i = 0; i < this.keys.length; i++) {\r\n      entries.push([this.keys[i], this.values[i]]);\r\n    }\r\n    return entries;\r\n  }\r\n\r\n  all(): Dictionary {\r\n    return this.keys.reduce((object: Dictionary, key: string, i) => {\r\n      object[key] = this.values[i];\r\n      return object;\r\n    }, {});\r\n  }\r\n\r\n  *[Symbol.iterator]() {\r\n    const length = this.keys.length;\r\n    for (let i = 0; i < length; i++) {\r\n      yield [this.keys[i], this.values[i]];\r\n    }\r\n  }\r\n}\r\n\r\nexport default Path;","export type Dictionary = { [key: string]: string };\r\nexport type Tuple<T> = [T, T];\r\n\r\nexport class Query extends Map<string, string> {\r\n  static from(object: Dictionary): Query {\r\n    return new Query(Object.entries(object));\r\n  }\r\n\r\n  static parse(string: string): Query {\r\n    if (string.startsWith('?')) {\r\n      string = string.substring(1);\r\n    }\r\n\r\n    let entries: Tuple<string>[] = [];\r\n    if (string !== '') {\r\n      entries = string.split('&')\r\n        .map((substring) => (substring.split('=') as Tuple<string>));\r\n    }\r\n\r\n    return new Query(entries);\r\n  }\r\n\r\n  toString(): string {\r\n    let string = '';\r\n    for (const [key, value] of this) {\r\n      string += `&${key}=${value}`;\r\n    }\r\n    return string.substring(1);\r\n  }\r\n}","/**\r\n * Append a leading slash, and remove all excess slashes.\r\n */\r\nexport function normalize(path: string): string {\r\n  return ('/' + path).replace(/[\\/]+/g, '/');\r\n}\r\n\r\n/**\r\n * Determines if the given object is a callable function.\r\n * An ES2015 class will return false, while ordinary functions,\r\n * arrow functions, generator functions and async functions return true.\r\n * @param object the object that is to be inspected\r\n * @returns `true` if the given object is a callable function\r\n */\r\nexport function isFunction(object: any): boolean {\r\n  if (!(typeof object === 'function')) {\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Values for `hasOwnProperty` on functions:\r\n   * \r\n   *           | Class | Ordinary | Arrow | Async | Generator |\r\n   * ---------------------------------------------------------|\r\n   * arguments | false |   true   | false | false |   false   |\r\n   * prototype | true  |   true   | false | false |   true    |\r\n   * \r\n   */\r\n\r\n  const tag = object[Symbol.toStringTag];\r\n  if (tag === 'AsyncFunction' || tag === 'GeneratorFunction') {\r\n    return true;\r\n  } else {\r\n    // Ordinary functions have an `arguments` property, which classes do not.\r\n    const isNormalFunction = object.hasOwnProperty('arguments');\r\n    // Arrow functions do not have a `prototype` property, which classes do.\r\n    const isArrowFunction = !object.hasOwnProperty('prototype');\r\n    return isNormalFunction || isArrowFunction;\r\n  }\r\n}\r\n\r\nexport function isPromise(object: any): boolean {\r\n  return object[Symbol.toStringTag] === 'Promise';\r\n}\r\n\r\nexport function clone<T>(object: T): T {\r\n  return Object.assign({}, object);\r\n}\r\n\r\nexport function freeze(object: any) {\r\n  return Object.freeze(object);\r\n}\r\n\r\nexport function always(): true {\r\n  return true;\r\n}\r\n\r\nexport function never(): false {\r\n  return false;\r\n}\r\n\r\nexport const EMPTY = freeze(Object.create(null));\r\n","import { Path, Parameters } from './path';\r\nimport { Query } from './query';\r\nimport {\r\n  normalize,\r\n  clone,\r\n  freeze,\r\n  always,\r\n  isFunction\r\n} from './utils';\r\n\r\nexport interface Module {\r\n  default: HTMLElement;\r\n}\r\n\r\nexport type Component = AsyncComponent | HTMLElement | string;\r\nexport type AsyncComponent = () => Promise<HTMLElement | Module>;\r\nexport type Guard = () => boolean;\r\n\r\nexport interface Record {\r\n  path: string;\r\n  component: Component;\r\n  exact?: boolean;\r\n  redirect?: string;\r\n  slot?: string;\r\n  guard?: Guard;\r\n  meta?: { [key: string]: any };\r\n  properties?: { [key: string]: any };\r\n  children?: Record[];\r\n}\r\n\r\nexport interface Snapshot {\r\n  readonly parameters: Parameters;\r\n  readonly query: Query;\r\n  readonly matched: string;\r\n  readonly hash: string;\r\n}\r\n\r\nexport class Route extends Path {\r\n  path: string;\r\n  component: Component;\r\n  exact: boolean;\r\n  children: Route[];\r\n  guard: Guard;\r\n  meta: any;\r\n  properties: any;\r\n  redirect?: string;\r\n  slot?: string;\r\n  private resolved?: HTMLElement;\r\n\r\n  static async import(identifier: Component): Promise<HTMLElement> {\r\n    if (typeof identifier === 'string') {\r\n      // If it's a string, assume that it has\r\n      // been defined, and return the constructor\r\n      // from the element registry\r\n      return customElements.get(identifier);\r\n  \r\n    } else if (isFunction(identifier)) {\r\n      // If it's a function, call it\r\n      let called = (identifier as AsyncComponent)();\r\n      // If it's a promise, resolve it\r\n      let resolved: any = await Promise.resolve(called);\r\n\r\n      // If the promise resolved directly to an element,\r\n      // return it\r\n      // otherwise, assume that it resolved to a module\r\n      // with the default export being the element\r\n      if (resolved.default) {\r\n        return resolved.default;\r\n      } else {\r\n        return resolved;\r\n      }\r\n    } else {\r\n      // If it's not a string or a promise,\r\n      // it's just\r\n      return identifier as HTMLElement;\r\n    }\r\n  }\r\n\r\n  constructor(record: Record) {\r\n    let {\r\n      path,\r\n      component,\r\n      exact,\r\n      redirect,\r\n      slot,\r\n      guard,\r\n      meta,\r\n      properties,\r\n      children\r\n    } = record;\r\n\r\n    if (exact == null) {\r\n      exact = (\r\n        children == null ||\r\n        children.length === 0\r\n      );\r\n    }\r\n\r\n    super(path, exact);\r\n    this.path = path;\r\n    this.exact = exact;\r\n    this.redirect = redirect;\r\n    this.component = component;\r\n    this.slot = slot;\r\n    this.guard = guard || always;\r\n    this.meta = freeze(meta || {});\r\n    this.properties = freeze(properties || {});\r\n    this.children = (children || []).map(child =>\r\n      createChildRoute(clone(child), this)\r\n    );\r\n  }\r\n\r\n  async import(): Promise<HTMLElement> {\r\n    if (this.resolved == null) {\r\n      this.resolved = await Route.import(this.component);\r\n    }\r\n    return this.resolved;\r\n  }\r\n\r\n  snapshot(path: string): Snapshot {\r\n    return freeze({\r\n      parameters: this.parse(path),\r\n      query: Query.parse(location.search),\r\n      matched: this.matched(path),\r\n      hash: location.hash.substring(1)\r\n    });\r\n  }\r\n}\r\n\r\nfunction createChildRoute(record: Record, parent: Route): Route {\r\n  if (record.path === '') {\r\n    record.path = parent.path;\r\n  } else {\r\n    record.path = normalize(parent.path + '/' + record.path);\r\n  }\r\n\r\n  if (record.redirect != null) {\r\n    if (record.redirect === '') {\r\n      record.redirect = parent.path;\r\n    } else {\r\n      record.redirect = normalize(parent.path + '/' + record.redirect);\r\n    }\r\n  }\r\n\r\n  return new Route(record);\r\n}\r\n","import EventEmitter from './event-emitter';\r\nimport { Record, Route } from './route';\r\nimport { EMPTY } from './utils';\r\n\r\nexport interface SearchResult {\r\n  matched: Route[];\r\n  /** \r\n   * If the search was redirected,\r\n   * the resulting path is different\r\n   * from the input path\r\n  */\r\n  path: string;\r\n}\r\n\r\nexport interface NavigationOptions {\r\n  data: any;\r\n  title: string;\r\n}\r\n\r\nexport default class Router extends EventEmitter {\r\n  static instance: Router;\r\n  elements: HTMLElement[];\r\n  matched: Route[];\r\n  routes: Route[];\r\n  middleware: Function[];\r\n  isConnected: boolean;\r\n  target?: HTMLElement;\r\n\r\n  constructor(records: Record[]) {\r\n    super();\r\n    this.isConnected = false;\r\n    this.elements = [];\r\n    this.matched = [];\r\n    this.middleware = [];\r\n    this.routes = records.map(record => new Route(record));\r\n    this.onPopstate = this.onPopstate.bind(this);\r\n    Router.instance = this;\r\n  }\r\n\r\n  async connect(target: HTMLElement) {\r\n    this.isConnected = true;\r\n    this.target = target;\r\n    window.addEventListener('popstate', this.onPopstate);\r\n    const currentPath = decodeURIComponent(location.pathname);\r\n    const { matched, path } = this.match(currentPath);\r\n\r\n    history.replaceState(history.state, document.title, path);\r\n    await this.render(matched);\r\n    this.emit('connect');\r\n  }\r\n\r\n  disconnect() {\r\n    this.isConnected = false;\r\n    window.removeEventListener('popstate', this.onPopstate);\r\n    this.teardown();\r\n    this.matched = [];\r\n    this.target = undefined;\r\n    this.emit('disconnect');\r\n  }\r\n\r\n  onPopstate() {\r\n    const to = decodeURIComponent(location.pathname);\r\n    const { matched, path } = this.match(to);\r\n    if (to !== path) {\r\n      history.replaceState(history.state, document.title, path);\r\n    }\r\n    this.emit('pop');\r\n    this.render(matched);\r\n  }\r\n\r\n  push(to: string, options: NavigationOptions = EMPTY) {\r\n    to = decodeURIComponent(to);\r\n    const { matched, path } = this.match(to);\r\n    const { data, title } = options;\r\n    history.pushState(data, title, path);\r\n    this.emit('push');\r\n    return this.render(matched);\r\n  }\r\n\r\n  replace(to: string, options: NavigationOptions = EMPTY) {\r\n    to = decodeURIComponent(to);\r\n    const { matched, path } = this.match(to);\r\n    const { data, title } = options;\r\n    history.replaceState(data, title, path);\r\n    this.emit('replace');\r\n    return this.render(matched);\r\n  }\r\n\r\n  pop(entries: number = -1) {\r\n    // triggers onPopstate(), so no need to render\r\n    // in this method call\r\n    history.go(entries);\r\n  }\r\n\r\n  search(path: string, routes: Route[], matched: Route[]): SearchResult {\r\n    const route = routes\r\n      .find(r => r.matches(path) && r.guard());\r\n\r\n    if (route) {\r\n      matched.push(route);\r\n      if (route.redirect) {\r\n        // transfer any matched parameters\r\n        const from = route.matched(path);\r\n        const to = route.redirect;\r\n        const redirected = route.transfer(from, to);\r\n        // and start over\r\n        return this.search(redirected, this.routes, []);\r\n      } else if (route.children) {\r\n        // Search through the children\r\n        return this.search(path, route.children, matched);\r\n      } else {\r\n        return { matched, path };\r\n      }\r\n    } else {\r\n      // End the search here\r\n      return { matched, path };\r\n    }\r\n  }\r\n\r\n  match(path: string): SearchResult {\r\n    return this.search(path, this.routes, []);\r\n  }\r\n\r\n  async render(matched: Route[]) {\r\n    if (this.target == undefined) {\r\n      return;\r\n    }\r\n\r\n    // Importing early in case both network\r\n    // and device is slow, but not awaiting\r\n    // it just yet.\r\n    const load = Promise.all(\r\n      matched.map(route => route.import())\r\n    );\r\n\r\n    // Find the index at which the matched routes\r\n    // differ from the active routes.\r\n    let start;\r\n    for (let i = 0; i < matched.length; i++) {\r\n      const match = matched[i];\r\n      if (this.matched.length < i + 1) {\r\n        start = i;\r\n        break;\r\n      } else {\r\n        const active = this.matched[i];\r\n        if (match !== active) {\r\n          start = i;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (start == null) {\r\n      start = matched.length;\r\n    }\r\n\r\n    this.matched = matched;\r\n\r\n    // Remove the obsolete elements\r\n    const removals = this.elements.slice(start);\r\n    while (removals.length > 0) {\r\n      const element = removals.pop();\r\n      element!.remove();\r\n    }\r\n\r\n    this.elements = this.elements.slice(0, start);\r\n\r\n    const components = await load;\r\n    // Create the new elements\r\n    const additions = components.slice(start)\r\n      // TODO: fix type\r\n      .map((Component: any) => new Component());\r\n\r\n    // Combine the newly created elements in order\r\n    // while being careful not to render them yet\r\n    for (let i = 0; i < additions.length - 1; i++) {\r\n      const parent = additions[i];\r\n      const child = additions[i + 1];\r\n      parent.appendChild(child);\r\n    }\r\n\r\n    this.elements = this.elements.concat(additions);\r\n\r\n    // In correct order, resolve any new properties\r\n    // Note: this happens before the new elements are connected\r\n    const url = decodeURIComponent(location.pathname);\r\n    for (let i = 0; i < this.elements.length; i++) {\r\n      // TODO: fix type\r\n      const element: any = this.elements[i];\r\n      const route = matched[i];\r\n      // TODO: fix type\r\n      const Component: any = components[i];\r\n      const snapshot = route.snapshot(url);\r\n      const parameters = snapshot.parameters;\r\n      const options = Component.properties;\r\n      if (options != undefined) {\r\n        // Resolve parameters from paths\r\n        for (const [key, value] of parameters) {\r\n          if (options.hasOwnProperty(key)) {\r\n            element[key] = value;\r\n          }\r\n        }\r\n\r\n        // Resolve additional properties from route\r\n        for (const key in route.properties) {\r\n          if (options.hasOwnProperty(key)) {\r\n            const value = route.properties[key];\r\n            element[key] = value;\r\n          }\r\n        }\r\n      }\r\n\r\n      element.route = snapshot;\r\n\r\n      if (route.slot) {\r\n        element.setAttribute('slot', route.slot);\r\n      }\r\n    }\r\n\r\n    // If there are any additions, they need to be rendered\r\n    if (additions.length > 0) {\r\n      if (start > 0) {\r\n        // Some reuse\r\n        // Connect the new elements to the deepest reused element,\r\n        // implicitly rendering them\r\n        this.elements[start - 1].appendChild(additions[0]);\r\n      } else {\r\n        // No reuse\r\n        this.target.appendChild(this.elements[0]);\r\n      }\r\n    }\r\n\r\n    this.emit('render');\r\n  }\r\n\r\n  teardown() {\r\n    while (this.elements.length > 0) {\r\n      const element = this.elements.pop();\r\n      element!.remove();\r\n    }\r\n  }\r\n}\r\n"],"names":["[object Object]","this","map","Map","type","listener","listeners","has","get","Set","set","add","delete","detail","MATCH_ALL","CATCH_ALL","PARAMETER_PATTERN","MATCH_TRAILING_SLASH","WILDCARD_PATTERN","path","exact","match","temporary","replace","keys","exec","push","endsWith","pattern","RegExp","test","matched","Parameters","from","to","values","slice","transferred","i","length","key","indexOf","value","undefined","entries","reduce","object","Symbol","iterator","Query","Object","string","startsWith","substring","split","tag","toStringTag","isNormalFunction","hasOwnProperty","isArrowFunction","assign","freeze","EMPTY","create","Path","identifier","customElements","isFunction","called","resolved","Promise","resolve","default","record","component","redirect","slot","guard","meta","properties","children","super","always","child","createChildRoute","clone","Route","import","parameters","parse","query","location","search","hash","parent","normalize","EventEmitter","records","isConnected","elements","middleware","routes","onPopstate","bind","Router","instance","target","window","addEventListener","currentPath","decodeURIComponent","pathname","history","replaceState","state","document","title","render","emit","removeEventListener","teardown","options","data","pushState","go","route","find","r","matches","redirected","transfer","load","all","start","removals","pop","remove","components","additions","Component","appendChild","concat","url","element","snapshot","setAttribute"],"mappings":"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"}