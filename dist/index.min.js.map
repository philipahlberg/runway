{"version":3,"file":"index.min.js","sources":["../src/path.ts","../src/query.ts","../src/utils.ts","../src/route.ts","../src/router.ts"],"sourcesContent":["const MATCH_ALL = '[^/]*';\r\n\r\nconst CATCH_ALL = '([^/]+)';\r\n\r\nconst PARAMETER_PATTERN = /:([^\\/]+)/;\r\n\r\n// optional trailing slash\r\n// only matches the slash if nothing follows\r\nconst MATCH_TRAILING_SLASH = '(?:[\\/]?(?=$))?';\r\n\r\n// implements '**' as a wildcard\r\nconst WILDCARD_PATTERN = /\\*\\*/g;\r\n\r\nexport class Path {\r\n  path: string;\r\n  exact: boolean;\r\n  pattern: RegExp;\r\n  keys: string[];\r\n\r\n  /**\r\n   * \r\n   * @param input The path to compile\r\n   * @param exact Whether or not the pattern should match anything after the path\r\n   */\r\n  constructor(path: string = '', exact: boolean = false) {\r\n    this.path = path;\r\n    this.exact = exact;\r\n    // replace any wildcards with\r\n    // their corresponding expression\r\n    let temporary = path.replace(WILDCARD_PATTERN, MATCH_ALL);\r\n    \r\n    let match: RegExpExecArray | null;\r\n    let keys: string[] = [];\r\n    // convert :param to a catch-all group\r\n    // and save the keys\r\n    while ((match = PARAMETER_PATTERN.exec(temporary)) != null) {\r\n      temporary = temporary.replace(match[0], CATCH_ALL);\r\n      keys.push(match[1]);\r\n    }\r\n    \r\n    if (!temporary.endsWith('/')) {\r\n      temporary += MATCH_TRAILING_SLASH;\r\n    }\r\n    \r\n    temporary = exact ? `^${temporary}$` : `^${temporary}`;\r\n    const pattern = new RegExp(temporary, 'i');\r\n\r\n    this.keys = keys;\r\n    this.pattern = pattern;\r\n  }\r\n\r\n  /**\r\n   * Convenience function that mirrors RegExp.test\r\n   */\r\n  matches(path: string): boolean {\r\n    return this.pattern.test(path);\r\n  }\r\n\r\n  /**\r\n   * Find the matched part of the given path.\r\n   */\r\n  matched(path: string): string {\r\n    let matched = this.pattern.exec(path);\r\n    return matched && matched[0] || '';\r\n  }\r\n\r\n  /**\r\n   * Parse a path string for parameter values.\r\n   */\r\n  parse(path: string) {\r\n    return new Parameters(\r\n      path,\r\n      this.pattern,\r\n      this.keys\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Transfer matched parameters in the given url to\r\n   * the target path, filling in named parameters in if they exist.\r\n   * @param {String} from a matched url\r\n   * @param {String} to a path\r\n   * @return {String} The target path with parameters filled in\r\n   */\r\n  transfer(from: string, to: string): string {\r\n    const values = (this.pattern.exec(from) || []).slice(1);\r\n    let transferred = to;\r\n    let i = values.length;\r\n    while (i--) {\r\n      transferred = transferred\r\n        .replace(':' + this.keys[i], values[i]);\r\n    }\r\n\r\n    return transferred;\r\n  }\r\n}\r\n\r\nexport type StringDictionary = { [key: string]: string };\r\nexport type StringTuple = [string, string];\r\n\r\nexport class Parameters {\r\n  path: string;\r\n  keys: string[];\r\n  values: string[];\r\n\r\n  constructor(path: string, pattern: RegExp, keys: string[]) {\r\n    this.path = path;\r\n    this.keys = keys;\r\n    this.values = (pattern.exec(path) || []).slice(1);\r\n  }\r\n\r\n  get(key: string): string {\r\n    return this.values[this.keys.indexOf(key)];\r\n  }\r\n\r\n  set(key: string, value: string): string {\r\n    return this.path.replace(this.get(key), value);\r\n  }\r\n\r\n  has(key: string): boolean {\r\n    return this.get(key) !== undefined;\r\n  }\r\n\r\n  entries(): StringTuple[] {\r\n    let entries: StringTuple[] = [];\r\n    for (let i = 0; i < this.keys.length; i++) {\r\n      entries.push([this.keys[i], this.values[i]]);\r\n    }\r\n    return entries;\r\n  }\r\n\r\n  all(): StringDictionary {\r\n    return this.keys.reduce((object: StringDictionary, key: string, i) => {\r\n      object[key] = this.values[i];\r\n      return object;\r\n    }, {});\r\n  }\r\n\r\n  *[Symbol.iterator]() {\r\n    const length = this.keys.length;\r\n    for (let i = 0; i < length; i++) {\r\n      yield [this.keys[i], this.values[i]];\r\n    }\r\n  }\r\n}\r\n\r\nexport default Path;","export interface StringKeyedObject {\r\n  [key: string]: string;\r\n}\r\n\r\nexport type StringTuple = [string, string];\r\n\r\nexport interface Query {\r\n  new(entries: Array<any[]>): Query;\r\n}\r\n\r\nexport class Query extends Map<string, string> {\r\n  static from(object: StringKeyedObject): Query {\r\n    return new Query(Object.entries(object));\r\n  }\r\n\r\n  static of(...pairs: StringTuple[]): Query {\r\n    return new Query(pairs);\r\n  }\r\n\r\n  static parse(string: string): Query {\r\n    if (string.startsWith('?')) {\r\n      string = string.substring(1);\r\n    }\r\n\r\n    let entries: StringTuple[] = [];\r\n    if (string !== '') {\r\n      entries = string.split('&')\r\n        .map((substring) => (substring.split('=') as StringTuple));\r\n    }\r\n\r\n    return new Query(entries);\r\n  }\r\n\r\n  toString(): string {\r\n    let string = '';\r\n    for (const [key, value] of this) {\r\n      string += `&${key}=${value}`;\r\n    }\r\n    return string.substring(1);\r\n  }\r\n}","/**\r\n * Append a leading slash, and remove all excess slashes.\r\n */\r\nexport function normalize(path: string): string {\r\n  return ('/' + path).replace(/[\\/]+/g, '/');\r\n}\r\n\r\n/**\r\n * Determines if the given object is a callable function.\r\n * An ES2015 class will return false, while ordinary functions,\r\n * arrow functions, generator functions and async functions return true.\r\n * @param object the object that is to be inspected\r\n * @returns `true` if the given object is a callable function\r\n */\r\nexport function isFunction(object: any): boolean {\r\n  if (!(typeof object === 'function')) {\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Values for `hasOwnProperty` on functions:\r\n   * \r\n   *           | Class | Ordinary | Arrow | Async | Generator |\r\n   * ---------------------------------------------------------|\r\n   * arguments | false |   true   | false | false |   false   |\r\n   * prototype | true  |   true   | false | false |   true    |\r\n   * \r\n   */\r\n\r\n  const tag = object[Symbol.toStringTag];\r\n  if (tag === 'AsyncFunction' || tag === 'GeneratorFunction') {\r\n    return true;\r\n  } else {\r\n    // Ordinary functions have an `arguments` property, which classes do not.\r\n    const isNormalFunction = object.hasOwnProperty('arguments');\r\n    // Arrow functions do not have a `prototype` property, which classes do.\r\n    const isArrowFunction = !object.hasOwnProperty('prototype');\r\n    return isNormalFunction || isArrowFunction;\r\n  }\r\n}\r\n\r\nexport function isPromise(object: any): boolean {\r\n  return object[Symbol.toStringTag] === 'Promise';\r\n}\r\n\r\nexport function clone<T>(object: T): T {\r\n  return Object.assign({}, object);\r\n}\r\n\r\nexport function freeze(object: any) {\r\n  return Object.freeze(object);\r\n}\r\n\r\nexport function always(): true {\r\n  return true;\r\n}\r\n\r\nexport function never(): false {\r\n  return false;\r\n}\r\n\r\nexport const EMPTY = freeze(Object.create(null));\r\n","import { Path, Parameters } from './path';\r\nimport { Query } from './query';\r\nimport {\r\n  normalize,\r\n  clone,\r\n  freeze,\r\n  always,\r\n  isFunction\r\n} from './utils';\r\n\r\nexport interface Module {\r\n  default: HTMLElement;\r\n}\r\n\r\nexport type Component = AsyncComponent | HTMLElement | string;\r\nexport type AsyncComponent = () => Promise<HTMLElement | Module>;\r\nexport type Guard = () => boolean;\r\n\r\nexport interface Record {\r\n  path: string;\r\n  component: Component;\r\n  exact?: boolean;\r\n  redirect?: string;\r\n  slot?: string;\r\n  guard?: Guard;\r\n  meta?: { [key: string]: any };\r\n  properties?: { [key: string]: any };\r\n  children?: Record[];\r\n}\r\n\r\nexport interface Snapshot {\r\n  readonly parameters: Parameters;\r\n  readonly query: Query;\r\n  readonly matched: string;\r\n  readonly hash: string;\r\n}\r\n\r\nexport class Route extends Path {\r\n  path: string;\r\n  component: Component;\r\n  exact: boolean;\r\n  children: Route[];\r\n  guard: Guard;\r\n  meta: any;\r\n  properties: any;\r\n  redirect?: string;\r\n  slot?: string;\r\n  private resolved?: HTMLElement;\r\n\r\n  static async import(identifier: Component): Promise<HTMLElement> {\r\n    if (typeof identifier === 'string') {\r\n      // If it's a string, assume that it has\r\n      // been defined, and return the constructor\r\n      // from the element registry\r\n      return customElements.get(identifier);\r\n  \r\n    } else if (isFunction(identifier)) {\r\n      // If it's a function, call it\r\n      let called = (identifier as AsyncComponent)();\r\n      // If it's a promise, resolve it\r\n      let resolved: any = await Promise.resolve(called);\r\n\r\n      // If the promise resolved directly to an element,\r\n      // return it\r\n      // otherwise, assume that it resolved to a module\r\n      // with the default export being the element\r\n      if (resolved.default) {\r\n        return resolved.default;\r\n      } else {\r\n        return resolved;\r\n      }\r\n    } else {\r\n      // If it's not a string or a promise,\r\n      // it's just\r\n      return identifier as HTMLElement;\r\n    }\r\n  }\r\n\r\n  constructor(record: Record) {\r\n    super(record.path, record.exact);\r\n    this.path = record.path;\r\n    this.exact = record.exact === true;\r\n    this.redirect = record.redirect;\r\n    this.component = record.component;\r\n    this.slot = record.slot;\r\n    this.guard = record.guard || always;\r\n    this.meta = freeze(record.meta || {});\r\n    this.properties = freeze(record.properties || {});\r\n    this.children = (record.children || []).map(child =>\r\n      createChildRoute(clone(child), this)\r\n    );\r\n  }\r\n\r\n  async import(): Promise<HTMLElement> {\r\n    if (this.resolved == null) {\r\n      this.resolved = await Route.import(this.component);\r\n    }\r\n    return this.resolved;\r\n  }\r\n\r\n  snapshot(path: string): Snapshot {\r\n    return freeze({\r\n      parameters: this.parse(path),\r\n      query: Query.parse(location.search),\r\n      matched: this.matched(path),\r\n      hash: location.hash.substring(1)\r\n    });\r\n  }\r\n}\r\n\r\nfunction createChildRoute(record: Record, parent: Route): Route {\r\n  if (record.path === '') {\r\n    record.path = parent.path;\r\n  } else {\r\n    record.path = normalize(parent.path + '/' + record.path);\r\n  }\r\n\r\n  if (record.redirect != null) {\r\n    if (record.redirect === '') {\r\n      record.redirect = parent.path;\r\n    } else {\r\n      record.redirect = normalize(parent.path + '/' + record.redirect);\r\n    }\r\n  }\r\n\r\n  if (record.children == null) {\r\n    record.exact = true;\r\n  }\r\n\r\n  return new Route(record);\r\n}\r\n","import { Record, Route } from './route';\r\nimport { EMPTY } from './utils';\r\n\r\nexport interface SearchResult {\r\n  matched: Route[];\r\n  /** \r\n   * If the search was redirected,\r\n   * the resulting path is different\r\n   * from the input path\r\n  */\r\n  path: string;\r\n}\r\n\r\nexport interface NavigationOptions {\r\n  data: any;\r\n  title: string;\r\n}\r\n\r\nexport default class Router {\r\n  static instance: Router;\r\n  elements: HTMLElement[];\r\n  matched: Route[];\r\n  routes: Route[];\r\n  target?: HTMLElement;\r\n  isConnected: boolean;\r\n\r\n  constructor(records: Record[], target?: HTMLElement) {\r\n    this.isConnected = false;\r\n    this.elements = [];\r\n    this.matched = [];\r\n    this.routes = records.map(record => new Route(record));\r\n    this.onPopstate = this.onPopstate.bind(this);\r\n\r\n    Router.instance = this;\r\n\r\n    if (target) {\r\n      this.connect(target);\r\n    }\r\n  }\r\n\r\n  connect(target: HTMLElement) {\r\n    this.isConnected = true;\r\n    this.target = target;\r\n    window.addEventListener('popstate', this.onPopstate);\r\n    const currentPath = decodeURIComponent(location.pathname);\r\n    const { matched, path } = this.match(currentPath);\r\n    history.replaceState(history.state, document.title, path);\r\n    return this.render(matched);\r\n  }\r\n\r\n  disconnect() {\r\n    this.isConnected = false;\r\n    window.removeEventListener('popstate', this.onPopstate);\r\n    this.teardown();\r\n    this.matched = [];\r\n    this.target = undefined;\r\n  }\r\n\r\n  onPopstate() {\r\n    const path = decodeURIComponent(location.pathname);\r\n    const { matched } = this.match(path);\r\n    this.render(matched);\r\n  }\r\n\r\n  push(to: string, options: NavigationOptions = EMPTY) {\r\n    to = decodeURIComponent(to);\r\n    const { matched, path } = this.match(to);\r\n    const { data, title } = options;\r\n    history.pushState(data, title, path);\r\n    return this.render(matched);\r\n  }\r\n\r\n  replace(to: string, options: NavigationOptions = EMPTY) {\r\n    to = decodeURIComponent(to);\r\n    const { matched, path } = this.match(to);\r\n    const { data, title } = options;\r\n    history.replaceState(data, title, path);\r\n    return this.render(matched);\r\n  }\r\n\r\n  search(path: string, routes: Route[], matched: Route[]): SearchResult {\r\n    const route = routes\r\n      .find(r => r.matches(path) && r.guard());\r\n\r\n    if (route) {\r\n      matched.push(route);\r\n      if (route.redirect) {\r\n        // transfer any matched parameters\r\n        const from = route.matched(path);\r\n        const to = route.redirect;\r\n        const redirected = route.transfer(from, to);\r\n        // and start over\r\n        return this.search(redirected, this.routes, []);\r\n      } else if (route.children) {\r\n        // Search through the children\r\n        return this.search(path, route.children, matched);\r\n      } else {\r\n        return { matched, path };\r\n      }\r\n    } else {\r\n      // End the search here\r\n      return { matched, path };\r\n    }\r\n  }\r\n\r\n  match(path: string): SearchResult {\r\n    return this.search(path, this.routes, []);\r\n  }\r\n\r\n  async render(matched: Route[]) {\r\n    if (this.target == undefined) {\r\n      return;\r\n    }\r\n\r\n    // Importing early in case both network\r\n    // and device is slow, but not awaiting\r\n    // it just yet.\r\n    const load = Promise.all(\r\n      matched.map(route => route.import())\r\n    );\r\n\r\n    // Find the index at which the matched routes\r\n    // differ from the active routes.\r\n    let start;\r\n    for (let i = 0; i < matched.length; i++) {\r\n      const match = matched[i];\r\n      if (this.matched.length < i + 1) {\r\n        start = i;\r\n        break;\r\n      } else {\r\n        const active = this.matched[i];\r\n        if (match !== active) {\r\n          start = i;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (start == null) {\r\n      start = matched.length;\r\n    }\r\n\r\n    this.matched = matched;\r\n\r\n    // Remove the obsolete elements\r\n    const removals = this.elements.slice(start);\r\n    while (removals.length > 0) {\r\n      const element = removals.pop();\r\n      element!.remove();\r\n    }\r\n\r\n    this.elements = this.elements.slice(0, start);\r\n\r\n    const components = await load;\r\n    // Create the new elements\r\n    const additions = components.slice(start)\r\n      // TODO: fix type\r\n      .map((Component: any) => new Component());\r\n\r\n    // Combine the newly created elements in order\r\n    // while being careful not to render them yet\r\n    for (let i = 0; i < additions.length - 1; i++) {\r\n      const parent = additions[i];\r\n      const child = additions[i + 1];\r\n      parent.appendChild(child);\r\n    }\r\n\r\n    this.elements = this.elements.concat(additions);\r\n\r\n    // In correct order, resolve any new properties\r\n    // Note: this happens before the new elements are connected\r\n    const url = decodeURIComponent(location.pathname);\r\n    for (let i = 0; i < this.elements.length; i++) {\r\n      // TODO: fix type\r\n      const element: any = this.elements[i];\r\n      const route = matched[i];\r\n      // TODO: fix type\r\n      const Component: any = components[i];\r\n\r\n      const snapshot = route.snapshot(url);\r\n\r\n      const parameters = snapshot.parameters;\r\n      const options = Component.properties;\r\n      if (options != undefined) {\r\n        // Resolve parameters from paths\r\n        for (const [key, value] of parameters) {\r\n          if (options.hasOwnProperty(key)) {\r\n            element[key] = value;\r\n          }\r\n        }\r\n\r\n        // Resolve additional properties from route\r\n        for (const key in route.properties) {\r\n          if (options.hasOwnProperty(key)) {\r\n            const value = route.properties[key];\r\n            element[key] = value;\r\n          }\r\n        }\r\n      }\r\n\r\n      element.route = snapshot;\r\n\r\n      if (route.slot) {\r\n        element.setAttribute('slot', route.slot);\r\n      }\r\n    }\r\n\r\n    // If there are any additions, they need to be rendered\r\n    if (additions.length > 0) {\r\n      if (start > 0) {\r\n        // Some reuse\r\n        // Connect the new elements to the deepest reused element,\r\n        // implicitly rendering them\r\n        this.elements[start - 1].appendChild(additions[0]);\r\n      } else {\r\n        // No reuse\r\n        this.target.appendChild(this.elements[0]);\r\n      }\r\n    }\r\n  }\r\n\r\n  teardown() {\r\n    while (this.elements.length > 0) {\r\n      const element = this.elements.pop();\r\n      element!.remove();\r\n    }\r\n  }\r\n}\r\n"],"names":["MATCH_ALL","CATCH_ALL","PARAMETER_PATTERN","MATCH_TRAILING_SLASH","WILDCARD_PATTERN","[object Object]","path","exact","this","match","temporary","replace","keys","exec","push","endsWith","pattern","RegExp","test","matched","Parameters","from","to","values","slice","transferred","i","length","key","indexOf","value","get","undefined","entries","reduce","object","Symbol","iterator","Map","Query","Object","pairs","string","startsWith","substring","split","map","tag","toStringTag","isNormalFunction","hasOwnProperty","isArrowFunction","assign","freeze","EMPTY","create","Path","identifier","customElements","isFunction","called","resolved","Promise","resolve","default","record","super","redirect","component","slot","guard","always","meta","properties","children","child","createChildRoute","clone","Route","import","parameters","parse","query","location","search","hash","parent","normalize","records","target","isConnected","elements","routes","onPopstate","bind","Router","instance","connect","window","addEventListener","currentPath","decodeURIComponent","pathname","history","replaceState","state","document","title","render","removeEventListener","teardown","options","data","pushState","route","find","r","matches","redirected","transfer","load","all","start","removals","pop","remove","components","additions","Component","appendChild","concat","url","element","snapshot","setAttribute"],"mappings":"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"}