{"version":3,"file":"index.min.js","sources":["../src/event-emitter.ts","../node_modules/@philipahlberg/query/dist/index.js","../node_modules/@philipahlberg/path/dist/index.js","../node_modules/@philipahlberg/scratchpad/dist/index.js","../src/utils.ts","../src/route.ts","../src/history.ts","../src/router.ts","../src/router-link.ts"],"sourcesContent":["import { EventEmitterListener } from './types';\r\n\r\nexport class EventEmitter {\r\n  map: Map<string, Set<EventEmitterListener>>;\r\n\r\n  constructor() {\r\n    this.map = new Map();\r\n  }\r\n\r\n  on(type: string, listener: EventEmitterListener) {\r\n    let listeners;\r\n    if (!this.map.has(type)) {\r\n      listeners = new Set();\r\n      this.map.set(type, listeners);\r\n    } else {\r\n      listeners = this.map.get(type);\r\n    }\r\n    listeners!.add(listener);\r\n  }\r\n\r\n  off(type: string, listener: EventEmitterListener) {\r\n    if (!this.map.has(type)) {\r\n      return;\r\n    }\r\n\r\n    const listeners = this.map.get(type);\r\n    listeners!.delete(listener);\r\n  }\r\n\r\n  emit(type: string, detail?: any) {\r\n    if (!this.map.has(type)) {\r\n      return;\r\n    }\r\n\r\n    const listeners = this.map.get(type);\r\n    for (const listener of listeners!) {\r\n      listener(detail);\r\n    }\r\n  }\r\n}","export class Query extends Map {\r\n    static from(object) {\r\n        return new Query(Object.entries(object));\r\n    }\r\n    static parse(string) {\r\n        if (/\\?/.test(string)) {\r\n            string = string.replace(/^.*\\?/, '');\r\n        }\r\n        if (/#/.test(string)) {\r\n            string = string.replace(/#.*$/, '');\r\n        }\r\n        let entries = [];\r\n        if (string !== '') {\r\n            entries = string.split('&')\r\n                .map((substring) => substring.split('='));\r\n        }\r\n        return new Query(entries);\r\n    }\r\n    toString() {\r\n        return Array.from(this.entries())\r\n            .map(entry => entry.join('='))\r\n            .join('&');\r\n    }\r\n}\r\nexport default Query;\r\n","/**\r\n * Matches anything until the next '/', '?' or '#'.\r\n * Replacement for wildcards in path declarations when building a RegExp.\r\n */\r\nconst MATCH_ALL = '[^/?#]*';\r\n/**\r\n * Captures anything until the next '/', '?' or '#'.\r\n * Replacement for parameters in path declarations when building a RegExp.\r\n */\r\nconst CATCH_ALL = '([^/?#]+)';\r\n/**\r\n * Matches an optional trailing '/', if it is not followed by anything.\r\n * Appended to the end of path declarations when building a RegExp.\r\n *\r\n * Notes:\r\n * - Does nothing on its own\r\n * - Does nothing without a trailing '$'\r\n *\r\n * @example\r\n * const pattern = new RegExp('^/abc' + MATCH_TRAILING_SLASH + '$');\r\n * pattern.test('/abc'); // => true\r\n * pattern.test('/abc/'); // => true\r\n * pattern.test('/abc/def'); // => false\r\n *\r\n */\r\nconst MATCH_TRAILING_SLASH = '(?:[/]?(?=$))?';\r\n/**\r\n * Matches an optional query string.\r\n */\r\nconst MATCH_TRAILING_QUERY = '(?:\\\\?.*)?';\r\n/**\r\n * Matches an optional hash string.\r\n */\r\nconst MATCH_TRAILING_HASH = '(?:#.*)?';\r\n/**\r\n * Matches '**'.\r\n *\r\n * Determines where to swap in a match-all pattern.\r\n */\r\nconst WILDCARD_PATTERN = /\\*\\*/g;\r\n/**\r\n * Matches ':param' and captures 'param'.\r\n *\r\n * Determines where to swap in a catch-all pattern, or\r\n * extracts parameter names from a path.\r\n */\r\nconst PARAMETER_PATTERN = /:([^\\/?#]+)/g;\n\n/**\r\n * Extract the keys in a path declaration.\r\n * @example\r\n * parse('/:a/:b/:c'); // => ['a', 'b', 'c']\r\n *\r\n * @param path A path declaration\r\n */\r\nconst parse = (path) => {\r\n    let keys = [];\r\n    let match;\r\n    while ((match = PARAMETER_PATTERN.exec(path)) != null) {\r\n        keys.push(match[1]);\r\n    }\r\n    return keys;\r\n};\n\n/**\r\n * Create a regular expression from a path with (optional) encoded parameters in it.\r\n * `exact` determines if the resulting expression should match\r\n * any superset of the given path or only match equal segment-length paths.\r\n *\r\n * @example\r\n * // not exact\r\n * compile('/:a').test('/b'); // => true\r\n * compile('/:a').test('/a/b'); // => true\r\n * // exact\r\n * compile('/:a', true).test('/a'); // => true\r\n * compile('/:a', true).test('/a/b'); // => false\r\n *\r\n * @param path A path declaration\r\n * @param exact If `true`, the resulting expression will only match\r\n * 1:1 (instead of matching any superset of the given path).\r\n */\r\nconst compile = (path, exact = false) => (new RegExp('^' +\r\n    path\r\n        // Replace '**' with a matching group\r\n        .replace(WILDCARD_PATTERN, MATCH_ALL)\r\n        // Replace ':key' with a catching group\r\n        .replace(PARAMETER_PATTERN, CATCH_ALL)\r\n    // Match an optional trailing slash\r\n    + MATCH_TRAILING_SLASH\r\n    // If exact, only match completely\r\n    + (exact\r\n        ? MATCH_TRAILING_QUERY + MATCH_TRAILING_HASH + '$'\r\n        : ''), 'i'));\n\n/**\r\n * Retrieve the values embedded in a string using a\r\n * regular expression obtained from `compile`.\r\n *\r\n * @example\r\n * const pattern = compile('/:a');\r\n * execute(pattern, '/value'); // => ['value']\r\n *\r\n * @param pattern The pattern returned from `compile`\r\n * @param path The live path\r\n */\r\nconst execute = (pattern, path) => ((pattern.exec(path) || []).slice(1));\n\nconst zip = (a, b) => (a.map((v, i) => [v, b[i]]));\r\n/**\r\n * Convert an array of keys and an array of values into a Map.\r\n *\r\n * @example\r\n * const keys = parse('/:a/:b');\r\n * const pattern = compile('/:a/:b');\r\n * const values = execute(pattern, '/some/path');\r\n * map(keys, values); // => Map {'a' => 'some', 'b' => 'path'}\r\n *\r\n * @param keys The keys returned from `parse`\r\n * @param values The values returned from `execute`\r\n */\r\nconst map = (keys, values) => (new Map(zip(keys, values)));\n\n/**\r\n * Convert an array of keys and an array of values into a plain object.\r\n * @example\r\n * const keys = parse('/:a/:b');\r\n * const pattern = compile('/:a/:b');\r\n * const values = execute(pattern, '/some/path');\r\n * object(keys, values); // => { a: 'some', b: 'path' }\r\n *\r\n * @param keys The keys returned from `parse`\r\n * @param values The values returned from `execute`\r\n */\r\nconst object = (keys, values) => (keys.reduce((acc, key, i) => {\r\n    acc[key] = values[i];\r\n    return acc;\r\n}, {}));\n\nclass Path {\r\n    constructor(path, exact = false) {\r\n        this.keys = parse(path);\r\n        this.pattern = compile(path, exact);\r\n    }\r\n    /**\r\n     * Test if the Path matches the given string.\r\n     *\r\n     * @example\r\n     * const path = new Path('/:a/:b/:c');\r\n     * path.matches('/1/2/3'); // => true\r\n     * path.matches('/1/2'); // => false\r\n     * path.matches('/1/2/3/4'); // => true\r\n     *\r\n     * @param string The string to test against\r\n     */\r\n    matches(string) {\r\n        return this.pattern.test(string);\r\n    }\r\n    /**\r\n     * Extract the matched part of the given string according to this Path.\r\n     *\r\n     * @example\r\n     * const path = new Path('/:a/:b/:c');\r\n     * path.matched('/1/2/3'); // => '/1/2/3'\r\n     * path.matched('/1/2/3/4'); // => '1/2/3'\r\n     *\r\n     * @param string The string to match against\r\n     */\r\n    matched(string) {\r\n        const matched = this.pattern.exec(string);\r\n        return matched && matched[0] || '';\r\n    }\r\n    /**\r\n     * Extract the values in the given string according to this Path's\r\n     * initial declaration.\r\n     *\r\n     * @example\r\n     * const path = new Path('/:a/:b/:c');\r\n     * path.values('/1/2/3'); // => ['1', '2', '3']\r\n     *\r\n     * @param string The string to extract values from\r\n     */\r\n    values(string) {\r\n        return execute(this.pattern, string);\r\n    }\r\n    /**\r\n     * Extract the values in the given string, and combine them\r\n     * with the keys for this Path to create a Map instance.\r\n     *\r\n     * @example\r\n     * const path = new Path('/:a/:b/:c');\r\n     * path.toMap('/1/2/3'); // => Map { 'a' => '1', 'b' => '2', 'c' => '3' }\r\n     *\r\n     * @param string The string to extract values from\r\n     */\r\n    toMap(string) {\r\n        const values = this.values(string);\r\n        return map(this.keys, values);\r\n    }\r\n    /**\r\n     * Extract the values in the given string, and combine them\r\n     * with the keys for this Path to create a simple object.\r\n     *\r\n     * @example\r\n     * const path = new Path('/:a/:b/:c');\r\n     * path.toMap('/1/2/3'); // => { a: '1', b: '2', c: '3' }\r\n     *\r\n     * @param string The string to extract values from\r\n     */\r\n    toObject(string) {\r\n        const values = this.values(string);\r\n        return object(this.keys, values);\r\n    }\r\n    /**\r\n     * Transfer parameters in a string (`source`) according to the\r\n     * Path declaration to construct another path (`target`).\r\n     * @example\r\n     * const path = new Path('/:a/:b/:c');\r\n     * path.transfer('/1/2/3', '/:a'); // => '/1'\r\n     * path.transfer('/1/2/3', '/:b'); // => '/2'\r\n     * path.transfer('/1/2/3', '/:c/:b/:a/abc'); // => '/3/2/1/abc'\r\n     *\r\n     * @param source The string that contains values\r\n     * @param target The path that will receive values\r\n     */\r\n    transfer(source, target) {\r\n        const values = this.values(source);\r\n        let i = values.length;\r\n        while (i--) {\r\n            target = target\r\n                .replace(':' + this.keys[i], values[i]);\r\n        }\r\n        return target;\r\n    }\r\n}\n\nexport default Path;\nexport { Path };\n","/**\r\n * Convert 'PascalCase' or 'camelCase' to 'dash-case'.\r\n * @param str A PascalCase og camelCase string\r\n */\r\nfunction toDashCase(str) {\r\n    return str.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase();\r\n}\r\n/**\r\n * Convert 'dash-case' to 'camelCase'.\r\n * @param str A camelCase string\r\n */\r\nfunction toCamelCase(str) {\r\n    return str.replace(/-([a-z])/ig, (m) => m[1].toUpperCase());\r\n}\r\n/**\r\n * Determine if a given value can be interpreted as a boolean.\r\n * @example\r\n * isBoolean(true); // => true\r\n * isBoolean(false); // => true\r\n * isBoolean('false'); // => true\r\n * isBoolean('true'); // => true\r\n *\r\n * @param value The value to inspect\r\n */\r\nfunction isBoolean(value) {\r\n    return value != null && (value === 'false' || value === 'true' || typeof value === 'boolean');\r\n}\r\n/**\r\n * Coerce a value to a boolean, with special edge-case handling not present\r\n * in `Boolean`.\r\n * @example\r\n * Boolean('false'); // => true\r\n * toBoolean('false'); // => false\r\n *\r\n * @param value\r\n */\r\nfunction toBoolean(value) {\r\n    return value !== 'false' && Boolean(value);\r\n}\r\n/**\r\n *\r\n * @param value\r\n */\r\nfunction isPrimitive(value) {\r\n    const type = typeof value;\r\n    return type === 'number' ||\r\n        type === 'string' ||\r\n        type === 'boolean' ||\r\n        type === 'symbol';\r\n}\r\n/**\r\n * Determines if the given object is a callable function.\r\n * An ES2015 class will return false, while ordinary functions,\r\n * arrow functions, generator functions and async functions return true.\r\n */\r\nfunction isCallable(object) {\r\n    if (!(typeof object === 'function')) {\r\n        return false;\r\n    }\r\n    /**\r\n     * Values for `hasOwnProperty` on functions:\r\n     *\r\n     *           | Class | Ordinary | Arrow | Async | Generator |\r\n     * ---------------------------------------------------------|\r\n     * arguments | false |   true   | false | false |   false   |\r\n     * prototype | true  |   true   | false | false |   true    |\r\n     *\r\n     */\r\n    const tag = object[Symbol.toStringTag];\r\n    if (tag === 'AsyncFunction' || tag === 'GeneratorFunction') {\r\n        return true;\r\n    }\r\n    else if (!object.hasOwnProperty('prototype')) {\r\n        // Arrow functions do not have a `prototype` property, which classes do.\r\n        return true;\r\n    }\r\n    else {\r\n        // // Ordinary functions have an `arguments` property, which classes do not.\r\n        // Note: Does not work in certain environments.\r\n        // RegExp method is more reliable.\r\n        // const isNormalFunction = object.hasOwnProperty('arguments');\r\n        return !/class/.test(object.toString());\r\n    }\r\n}\r\n/**\r\n * Determine if the given object is a promise.\r\n * @param object The object to inspect\r\n */\r\nfunction isPromise(object) {\r\n    return object[Symbol.toStringTag] === 'Promise';\r\n}\r\n/**\r\n * Determine if the given object is an ES module (the return value of `import()`)\r\n * or a shim (like `require()`)\r\n * @example\r\n * isModule(import('./module.js')); // => true\r\n * // Does not work with `await`:\r\n * isModule(await import('./module.js')); // => false\r\n *\r\n * @param object The object to inspect\r\n */\r\nfunction isModule(object) {\r\n    return object[Symbol.toStringTag] === 'Module' || object.__esModule === true;\r\n}\r\nfunction has(target, prop) {\r\n    return target.hasOwnProperty(prop);\r\n}\r\nfunction empty() {\r\n    return Object.create(null);\r\n}\r\n/**\r\n * Shorthand for `Object.assign`.\r\n */\r\nfunction clone(object) {\r\n    return Object.assign(empty(), object);\r\n}\r\n/**\r\n * Shorthand for `Object.freeze`.\r\n * @param object\r\n */\r\nfunction freeze(object) {\r\n    return Object.freeze(object);\r\n}\r\n/**\r\n * Always returns `true`.\r\n */\r\nfunction always() {\r\n    return true;\r\n}\r\n/**\r\n * Always returns `false`.\r\n */\r\nfunction never() {\r\n    return false;\r\n}\r\n/**\r\n * Shorthand for `decodeURIComponent`.\r\n */\r\nfunction decode(str) {\r\n    return decodeURIComponent(str);\r\n}\r\n/**\r\n * Combine two arrays to an array of tuples.\r\n */\r\nfunction zip(a, b) {\r\n    return a.map((v, i) => [v, b[i]]);\r\n}\r\n/**\r\n * Separate an array of tuples into two arrays.\r\n */\r\nfunction unzip(array) {\r\n    return [\r\n        array.map(v => v[0]),\r\n        array.map(v => v[1])\r\n    ];\r\n}\r\n/**\r\n * Convert an array of tuples to an object in which each key\r\n * is the first element of the tuple and the value is the\r\n * second element of the tuple.\r\n */\r\nfunction dictionary(pairs) {\r\n    let index = -1;\r\n    const length = pairs.length;\r\n    const result = {};\r\n    while (++index < length) {\r\n        const pair = pairs[index];\r\n        result[pair[0]] = pair[1];\r\n    }\r\n    return result;\r\n}\r\nconst EMPTY = freeze(empty());\r\nconst timeouts = new WeakMap();\r\nfunction debounce(fn) {\r\n    const wrapper = () => {\r\n        fn();\r\n        timeouts.delete(fn);\r\n    };\r\n    return () => {\r\n        clearTimeout(timeouts.get(fn));\r\n        timeouts.set(fn, setTimeout(wrapper, 1));\r\n    };\r\n}\r\nconst called = new WeakSet();\r\nfunction once(fn) {\r\n    return () => {\r\n        if (!called.has(fn)) {\r\n            fn();\r\n            called.add(fn);\r\n        }\r\n    };\r\n}\r\nconst input = new WeakMap();\r\nconst output = new WeakMap();\r\nfunction cache(fn) {\r\n    return (...args) => {\r\n        const previous = input.get(fn);\r\n        const equal = previous && args.every((item, i) => item === previous[i]);\r\n        if (equal) {\r\n            return output.get(fn);\r\n        }\r\n        else {\r\n            const result = fn(...args);\r\n            input.set(fn, args);\r\n            output.set(fn, result);\r\n            return result;\r\n        }\r\n    };\r\n}\r\n/**\r\n * `requestIdleCallback` as a Promise.\r\n */\r\nfunction idle() {\r\n    return new Promise(resolve => {\r\n        requestIdleCallback(() => {\r\n            resolve();\r\n        });\r\n    });\r\n}\r\n/**\r\n * `setTimeout` as a Promise.\r\n * @param ms The minimum number of milliseconds that should elapse\r\n * before the function is called.\r\n */\r\nfunction timeout(ms = 0) {\r\n    return new Promise(resolve => {\r\n        setTimeout(() => {\r\n            resolve();\r\n        }, ms);\r\n    });\r\n}\r\n/**\r\n * `requestAnimationFrame` as a Promise.\r\n */\r\nfunction frame() {\r\n    return new Promise(resolve => {\r\n        requestAnimationFrame(() => {\r\n            resolve();\r\n        });\r\n    });\r\n}\r\nfunction createElement(tag, options = EMPTY, children = []) {\r\n    const attributes = options.attributes || {};\r\n    const properties = options.properties || {};\r\n    const namespace = options.namespace;\r\n    const ns = namespace && namespace.toLowerCase() === 'svg'\r\n        ? 'http://www.w3.org/2000/svg'\r\n        : 'http://www.w3.org/1999/xhtml';\r\n    const element = document.createElementNS(ns, tag);\r\n    Object.assign(element, properties);\r\n    for (const key in attributes) {\r\n        element.setAttribute(key, attributes[key]);\r\n    }\r\n    for (const node of children) {\r\n        element.appendChild(node);\r\n    }\r\n    return element;\r\n}\n\nexport { toDashCase, toCamelCase, isBoolean, toBoolean, isPrimitive, isCallable, isPromise, isModule, has, empty, clone, freeze, always, never, decode, zip, unzip, dictionary, EMPTY, debounce, once, cache, idle, timeout, frame, createElement };\n","import { ModuleDescriptor } from './types';\r\n\r\n/**\r\n * Append a leading slash, and remove all excess slashes.\r\n */\r\nexport function normalize(path: string): string {\r\n  return ('/' + path).replace(/[\\/]+/g, '/');\r\n}\r\n\r\n/**\r\n * Shorthand for `decodeURIComponent`\r\n */\r\nexport function decode(str: string): string {\r\n  return decodeURIComponent(str);\r\n}\r\n\r\nexport function isFunction(object: any): object is Function {\r\n  return typeof object === 'function';\r\n}\r\n\r\nexport function isGeneratorFunction(object: any): object is GeneratorFunction {\r\n  return object[Symbol.toStringTag] === 'GeneratorFunction';\r\n}\r\n\r\nexport function isAsyncFunction(object: any): boolean {\r\n  return object[Symbol.toStringTag] === 'AsyncFunction';\r\n}\r\n\r\nexport function isArrowFunction(object: any): boolean {\r\n  return isFunction(object) &&\r\n    !isGeneratorFunction(object) &&\r\n    !object.hasOwnProperty('prototype');\r\n}\r\n\r\nexport interface Constructor<T> {\r\n  new (...args: any[]): T;\r\n}\r\n\r\nexport function isConstructible(object: any): object is Constructor<any> {\r\n  return isFunction(object) &&\r\n    !isGeneratorFunction(object) &&\r\n    !isAsyncFunction(object) &&\r\n    !object.hasOwnProperty('prototype');\r\n}\r\n\r\n/**\r\n * Determine if the given object is a Promise.\r\n */\r\nexport function isPromise(object: any): boolean {\r\n  return object[Symbol.toStringTag] === 'Promise';\r\n}\r\n\r\n/**\r\n * Determine if the given object is an ES module (the return value of `import()`)\r\n * or a shim (like `require()`)\r\n * @example\r\n * isModule(import('./module.js')); // => true\r\n * // Using `await` means it won't register as a module:\r\n * isModule(await import('./module.js')); // => false\r\n * \r\n * @param object The object to inspect\r\n */\r\nexport function isModule(object: any): object is PromiseLike<ModuleDescriptor> {\r\n  return object[Symbol.toStringTag] === 'Module' || object.__esModule === true;\r\n}\r\n\r\n/**\r\n * Shorthand for `Object.assign`.\r\n */\r\nexport function clone<T>(object: T): T {\r\n  return Object.assign(empty(), object);\r\n}\r\n\r\n/**\r\n * Shorthand for `Object.freeze`.\r\n */\r\nexport function freeze<T>(object: T): T {\r\n  return Object.freeze(object);\r\n}\r\n\r\n/**\r\n * Shorthand for `Object.create(null)`.\r\n */\r\nexport function empty() {\r\n  return Object.create(null);\r\n}\r\n\r\n/**\r\n * A frozen object with no prototype chain.\r\n */\r\nexport const EMPTY = freeze(Object.create(null));\r\n","import Query from '@philipahlberg/query';\r\nimport Path from '@philipahlberg/path';\r\nimport { empty, always } from '@philipahlberg/scratchpad';\r\nimport {\r\n  normalize,\r\n  decode\r\n} from './utils';\r\nimport {\r\n  Component,\r\n  ComponentFn,\r\n  GuardFn,\r\n  PropertiesFn,\r\n  Record,\r\n  Snapshot\r\n} from './types';\r\n\r\nexport class Route extends Path {\r\n  private static cache = new WeakMap<any, HTMLElement>();\r\n  path: string;\r\n  exact: boolean;\r\n  component: Component;\r\n  redirect?: string;\r\n  slot?: string;\r\n  guard: GuardFn;\r\n  properties: PropertiesFn;\r\n  children: Route[];\r\n\r\n  static async import(component: Component): Promise<HTMLElement> {\r\n    if (typeof component !== 'function') {\r\n      throw new TypeError('Component must be a class or function.');\r\n    }\r\n\r\n    if (HTMLElement.isPrototypeOf(component)) {\r\n      return component as HTMLElement;\r\n    } else {\r\n      const called = (component as ComponentFn)();\r\n      const resolved = await Promise.resolve(called);\r\n      if (resolved.default) {\r\n        return resolved.default;\r\n      } else {\r\n        return resolved as HTMLElement;\r\n      }\r\n    }\r\n  }\r\n\r\n  constructor(record: Record) {\r\n    let { path, component, exact,\r\n      redirect, slot, guard,\r\n      properties, children } = record;\r\n\r\n    // Path should be exact if the route\r\n    // does not have any children,\r\n    // but only if the record does not\r\n    // specifically declare anything\r\n    if (exact == null) {\r\n      exact = (\r\n        children == null ||\r\n        children.length === 0\r\n      );\r\n    }\r\n\r\n    super(path, exact);\r\n    this.path = path;\r\n    this.exact = exact;\r\n    this.redirect = redirect;\r\n    this.component = typeof component === 'string'\r\n      ? customElements.get(component)\r\n      : component;\r\n    this.slot = slot;\r\n    this.guard = guard || always;\r\n    this.properties = properties || empty;\r\n    this.children = (children || []).map(child =>\r\n      createChildRoute(child, this)\r\n    );\r\n  }\r\n\r\n  async import(): Promise<HTMLElement> {\r\n    const cache = Route.cache;\r\n    const component = this.component;\r\n\r\n    if (HTMLElement.isPrototypeOf(component)) {\r\n      return component as HTMLElement;\r\n    } else if (cache.has(component)) {\r\n      return cache.get(component)!;\r\n    } else {\r\n      const ctor = await Route.import(component);\r\n      cache.set(component, ctor);\r\n      return ctor;\r\n    }\r\n  }\r\n\r\n  snapshot(source: Location | URL): Snapshot {\r\n    const { pathname, search, hash } = source;\r\n    return {\r\n      parameters: this.toMap(decode(pathname)),\r\n      query: Query.parse(decode(search)),\r\n      matched: this.matched(decode(pathname)),\r\n      hash: hash.substring(1)\r\n    };\r\n  }\r\n}\r\n\r\nfunction createChildRoute(record: Record, parent: Route): Route {\r\n  if (record.path === '') {\r\n    record.path = parent.path;\r\n  } else {\r\n    record.path = normalize(parent.path + '/' + record.path);\r\n  }\r\n  if (record.redirect != null) {\r\n    record.redirect = normalize(parent.path + '/' + record.redirect);\r\n  }\r\n  return new Route(record);\r\n}\r\n","import { EMPTY, decode } from './utils';\r\nimport { PopstateListener, NavigationOptions } from './types';\r\n\r\nconst h = history;\r\n\r\nexport class History {\r\n  onPopstate: PopstateListener;\r\n\r\n  constructor(listener: PopstateListener) {\r\n    this.onPopstate = listener;\r\n    this.onpop = this.onpop.bind(this);\r\n  }\r\n\r\n  connect() {\r\n    window.addEventListener('popstate', this.onpop);\r\n  }\r\n\r\n  disconnect() {\r\n    window.removeEventListener('popstate', this.onpop);\r\n  }\r\n\r\n  onpop() {\r\n    const to = decode(location.pathname);\r\n    this.onPopstate(to);\r\n  }\r\n\r\n  push(path: string, options: NavigationOptions = EMPTY) {\r\n    const { data, title } = options;\r\n    h.pushState(data, title, path);\r\n  }\r\n\r\n  replace(path: string, options: NavigationOptions = EMPTY) {\r\n    const { data, title } = options;\r\n    h.replaceState(data, title, path);\r\n  }\r\n\r\n  go(delta: number) {\r\n    h.go(delta);\r\n  }\r\n}","import { EventEmitter } from './event-emitter';\r\nimport { Route } from './route';\r\nimport { History } from './history';\r\nimport { decode } from './utils';\r\nimport { Record, Constructor, NavigationOptions } from './types';\r\n\r\nexport interface SearchResult {\r\n  matched: Route[];\r\n  path: string;\r\n}\r\n\r\nexport class Router extends EventEmitter {\r\n  static instance: Router;\r\n  isConnected: boolean;\r\n  history: History;\r\n  routes: Route[];\r\n  elements: HTMLElement[];\r\n  matched: Route[];\r\n  root?: HTMLElement;\r\n\r\n  constructor(records: Record[]) {\r\n    super();\r\n    this.isConnected = false;\r\n    this.elements = [];\r\n    this.matched = [];\r\n    this.routes = records.map(record => new Route(record));\r\n    this.onpop = this.onpop.bind(this);\r\n    this.history = new History(this.onpop);\r\n    Router.instance = this;\r\n  }\r\n\r\n  /**\r\n   * Connect the router to an element.\r\n   * This checks the current location for matching,\r\n   * and renders those matched elements.\r\n   */\r\n  async connect(root: HTMLElement): Promise<void> {\r\n    this.isConnected = true;\r\n    this.root = root;\r\n    const to = decode(location.pathname);\r\n    const { matched, path } = this.match(to);\r\n    this.history.connect();\r\n    this.history.replace(path);\r\n    await this.render(matched);\r\n    this.emit('connect');\r\n  }\r\n\r\n  /**\r\n   * Disconnect the router from it's current root element.\r\n   * This removes all the elements currently rendered, and\r\n   * removes all listeners, effectively leaving the router inactive.\r\n   */\r\n  disconnect(): void {\r\n    this.isConnected = false;\r\n    this.matched = [];\r\n    this.root = undefined;\r\n    this.teardown();\r\n    this.history.disconnect();\r\n    this.emit('disconnect');\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  onpop(to: string): void {\r\n    const { matched, path } = this.match(to);\r\n    if (to !== path) {\r\n      this.history.replace(path);\r\n    }\r\n    this.emit('pop');\r\n    this.render(matched);\r\n  }\r\n\r\n  /**\r\n   * Push a history entry onto the stack.\r\n   */\r\n  push(to: string, options?: NavigationOptions): Promise<void> {\r\n    to = decode(to);\r\n    const { matched, path } = this.match(to);\r\n    this.history.push(path, options);\r\n    this.emit('push');\r\n    return this.render(matched);\r\n  }\r\n\r\n  /**\r\n   * Replace the topmost entry in the history stack.\r\n   */\r\n  replace(to: string, options?: NavigationOptions): Promise<void> {\r\n    to = decode(to);\r\n    const { matched, path } = this.match(to);\r\n    this.history.replace(path, options);\r\n    this.emit('replace');\r\n    return this.render(matched);\r\n  }\r\n\r\n  /**\r\n   * Traverse through the history stack.\r\n   */\r\n  go(entries: number) {\r\n    // triggers onpop(), so no need to render\r\n    // in this method call\r\n    this.history.go(entries);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  search(path: string, routes: Route[], matched: Route[]): SearchResult {\r\n    const route = routes.find(r => r.matches(path) && r.guard());\r\n\r\n    if (route) {\r\n      matched.push(route);\r\n      if (route.redirect) {\r\n        // transfer any matched parameters\r\n        const from = route.matched(path);\r\n        const to = route.redirect;\r\n        const redirected = route.transfer(from, to);\r\n        // and start over\r\n        return this.search(redirected, this.routes, []);\r\n      } else if (route.children) {\r\n        // Search through the children\r\n        return this.search(path, route.children, matched);\r\n      } else {\r\n        return { matched, path };\r\n      }\r\n    } else {\r\n      // End the search here\r\n      return { matched, path };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * Search for the elements that would match the given path.\r\n   * If a redirect is encountered, it will be followed.\r\n   * The resulting path and the matched elements are returned.\r\n   */\r\n  match(path: string): SearchResult {\r\n    return this.search(path, this.routes, []);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * Render the given routes.\r\n   * The routes are assumed to be nested.\r\n   */\r\n  async render(matched: Route[]) {\r\n    if (this.root == undefined) {\r\n      return;\r\n    }\r\n\r\n    // Importing early, but not awaiting, in case network is slow\r\n    const load = Promise.all(matched.map(route => route.import()));\r\n\r\n    // Find the index at which the matched routes\r\n    // differ from the active routes.\r\n    let start;\r\n    for (let i = 0; i < matched.length; i++) {\r\n      const match = matched[i];\r\n      if (this.matched.length < i + 1) {\r\n        start = i;\r\n        break;\r\n      } else {\r\n        const active = this.matched[i];\r\n        if (match !== active) {\r\n          start = i;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (start == null) {\r\n      start = matched.length;\r\n    }\r\n\r\n    this.matched = matched;\r\n\r\n    // Remove the obsolete elements from the DOM\r\n    const removals = this.elements.slice(start);\r\n    while (removals.length > 0) {\r\n      const element = removals.pop();\r\n      if (element && element.parentElement) {\r\n        element.parentElement.removeChild(element!);\r\n      }\r\n    }\r\n\r\n    // Discard references to the removed elements\r\n    this.elements = this.elements.slice(0, start);\r\n\r\n    // Wait for any asynchronous components to load\r\n    const components = await load;\r\n    // Create the new elements\r\n    const additions = components\r\n      .slice(start)\r\n      .map((Component: Constructor<HTMLElement>) => new Component());\r\n\r\n    this.elements = this.elements.concat(additions);\r\n\r\n    // Add slot attributes if needed\r\n    for (let i = start; i < this.elements.length; i++) {\r\n      const element: HTMLElement = this.elements[i];\r\n      const route = this.matched[i];\r\n      if (route.slot) {\r\n        element.setAttribute('slot', route.slot);\r\n      }\r\n    }\r\n\r\n    // Combine the newly created elements in order\r\n    // Note: they are not connected to the DOM here\r\n    for (let i = 0; i < additions.length - 1; i++) {\r\n      const parent = additions[i];\r\n      const child = additions[i + 1];\r\n      parent.appendChild(child);\r\n    }\r\n\r\n    // Resolve any new properties\r\n    this.updateProperties();\r\n\r\n    // If there are any additions, they need to be rendered\r\n    if (additions.length > 0) {\r\n      if (start > 0) {\r\n        // Some reuse\r\n        // Connect the new elements to the deepest reused element,\r\n        // implicitly rendering them\r\n        this.elements[start - 1].appendChild(additions[0]);\r\n      } else {\r\n        // No reuse\r\n        this.root.appendChild(this.elements[0]);\r\n      }\r\n    }\r\n\r\n    this.emit('render');\r\n  }\r\n\r\n  /**\r\n   * Update all `:param` bindings and `properties` functions in the tree.\r\n   */\r\n  updateProperties() {\r\n    for (let i = 0; i < this.elements.length; i++) {\r\n      const element = this.elements[i];\r\n      const options = customElements.get(\r\n        element.tagName.toLowerCase()\r\n      ).properties;\r\n      const route = this.matched[i];\r\n\r\n      if (options != undefined) {\r\n        const snapshot = route.snapshot(window.location);\r\n        const parameters = snapshot.parameters;\r\n        // Resolve parameters from path\r\n        for (const [key, value] of parameters) {\r\n          if (options.hasOwnProperty(key)) {\r\n            element[key] = value;\r\n          }\r\n        }\r\n\r\n        // Resolve additional properties from route\r\n        const properties = route.properties(snapshot);\r\n        for (const key in properties) {\r\n          if (options.hasOwnProperty(key)) {\r\n            const value = properties[key];\r\n            element[key] = value;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove all currently active elements.\r\n   */\r\n  teardown() {\r\n    while (this.elements.length > 0) {\r\n      const element = this.elements.pop();\r\n      if (element && element.parentElement) {\r\n        element.parentElement.removeChild(element!);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default Router;\r\n","import Router from './router';\r\nimport { decode } from './utils';\r\n\r\nexport class RouterLink extends HTMLElement {\r\n  static observedAttributes = ['disabled', 'to'];\r\n  static tagName = 'router-link';\r\n  private router: Router;\r\n\r\n  static install() {\r\n    customElements.define(this.tagName, this);\r\n  }\r\n\r\n  constructor() {\r\n    super();\r\n    this.router = Router.instance;\r\n    this.onClick = this.onClick.bind(this);\r\n    this.onChange = this.onChange.bind(this);\r\n  }\r\n\r\n  set to(v: string) {\r\n    this.setAttribute('to', v);\r\n  }\r\n\r\n  get to() {\r\n    return this.getAttribute('to') as string;\r\n  }\r\n\r\n  set exact(v: boolean) {\r\n    this.toggleAttribute('exact', v);\r\n    this.active = this.test(decode(location.pathname));\r\n  }\r\n\r\n  get exact(): boolean {\r\n    return this.hasAttribute('exact');\r\n  }\r\n\r\n  set active(v: boolean) {\r\n    this.toggleAttribute('active', v);\r\n  }\r\n\r\n  get active(): boolean {\r\n    return this.hasAttribute('active');\r\n  }\r\n\r\n  set disabled(v: boolean) {\r\n    this.toggleAttribute('disabled', v);\r\n  }\r\n\r\n  get disabled(): boolean {\r\n    return this.hasAttribute('disabled');\r\n  }\r\n\r\n  attributeChangedCallback(attr: string, oldValue: string, newValue: string) {\r\n    if (oldValue === newValue) {\r\n      return;\r\n    }\r\n\r\n    if (attr === 'disabled') {\r\n      const hasValue = newValue != null;\r\n      if (hasValue) {\r\n        this.active = false;\r\n        this.router.off('render', this.onChange);\r\n      } else {\r\n        this.router.on('render', this.onChange);\r\n        this.onChange();\r\n      }\r\n    } else if (attr === 'to') {\r\n      const a = this.querySelector('a');\r\n      if (a) {\r\n        a.href = newValue;\r\n      }\r\n      this.active = this.test(decode(location.pathname));\r\n    }\r\n  }\r\n\r\n  connectedCallback() {\r\n    const a = this.querySelector('a');\r\n    if (a) {\r\n      if (!this.to) {\r\n        this.to = decode(a.pathname);\r\n      } else {\r\n        a.href = this.to;\r\n      }\r\n    }\r\n    this.addEventListener('click', this.onClick);\r\n    this.router.on('render', this.onChange);\r\n    this.onChange();\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    this.removeEventListener('click', this.onClick);\r\n    this.router.off('render', this.onChange);\r\n  }\r\n\r\n  toggleAttribute(name: string, predicate: boolean) {\r\n    if (predicate != null) {\r\n      if (predicate) {\r\n        this.setAttribute(name, '');\r\n      } else {\r\n        this.removeAttribute(name);\r\n      }\r\n    } else {\r\n      this.toggleAttribute(name, !this.hasAttribute(name));\r\n    }\r\n  }\r\n\r\n  test(path: string): boolean {\r\n    const to = this.to;\r\n    if (to.startsWith('/')) {\r\n      return this.exact\r\n        ? path === to\r\n        : path.startsWith(to);\r\n    } else {\r\n      return path.endsWith(to);\r\n    }\r\n  }\r\n\r\n  onClick(event: MouseEvent) {\r\n    if (\r\n      // Ignore clicks with modifiers\r\n      event.metaKey ||\r\n      event.altKey ||\r\n      event.ctrlKey ||\r\n      event.shiftKey ||\r\n      // Ignore prevented clicks\r\n      event.defaultPrevented ||\r\n      // Ignore right mouse button clicks\r\n      (event.button !== undefined &&\r\n      event.button !== 0)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    event.preventDefault();\r\n    if (this.disabled || !this.to) {\r\n      return;\r\n    } else {\r\n      this.router.push(this.to);\r\n    }\r\n  }\r\n\r\n  onChange() {\r\n    this.active = this.test(decode(location.pathname));\r\n  }\r\n}\r\n\r\nexport default RouterLink;\r\n"],"names":["[object Object]","this","map","Map","type","listener","listeners","has","get","Set","set","add","delete","detail","Query","object","Object","entries","string","test","replace","split","substring","Array","from","entry","join","WILDCARD_PATTERN","PARAMETER_PATTERN","parse","path","match","keys","exec","push","compile","exact","RegExp","MATCH_TRAILING_QUERY","execute","pattern","slice","values","a","b","v","i","zip","reduce","acc","key","Path","matched","source","target","length","empty","create","always","freeze","str","decodeURIComponent","EMPTY","record","component","redirect","slot","guard","properties","children","super","customElements","child","parent","normalize","Route","createChildRoute","TypeError","HTMLElement","isPrototypeOf","called","resolved","Promise","resolve","default","cache","ctor","import","pathname","search","hash","parameters","toMap","decode","query","WeakMap","h","history","onPopstate","onpop","bind","window","addEventListener","removeEventListener","to","location","options","data","title","pushState","replaceState","delta","go","EventEmitter","records","isConnected","elements","routes","History","Router","instance","root","connect","render","emit","undefined","teardown","disconnect","route","find","r","matches","redirected","transfer","load","all","start","removals","element","pop","parentElement","removeChild","additions","Component","concat","setAttribute","appendChild","updateProperties","tagName","toLowerCase","snapshot","value","hasOwnProperty","router","onClick","onChange","define","getAttribute","toggleAttribute","active","hasAttribute","disabled","attr","oldValue","newValue","off","on","querySelector","href","name","predicate","removeAttribute","startsWith","endsWith","event","metaKey","altKey","ctrlKey","shiftKey","defaultPrevented","button","preventDefault","RouterLink"],"mappings":"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"}